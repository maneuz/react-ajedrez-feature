{"ast":null,"code":"/*\n * Copyright (c) 2020, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n *----------------------------------------------------------------------------*/\n\nvar Chess = function (fen) {\n  var BLACK = 'b';\n  var WHITE = 'w';\n  var EMPTY = -1;\n  var PAWN = 'p';\n  var KNIGHT = 'n';\n  var BISHOP = 'b';\n  var ROOK = 'r';\n  var QUEEN = 'q';\n  var KING = 'k';\n  var SYMBOLS = 'pnbrqkPNBRQK';\n  var DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\n  var POSSIBLE_RESULTS = ['1-0', '0-1', '1/2-1/2', '*'];\n  var PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15]\n  };\n  var PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1]\n  };\n\n  // prettier-ignore\n  var ATTACKS = [20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20];\n\n  // prettier-ignore\n  var RAYS = [17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0, 0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0, 0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0, -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17];\n  var SHIFTS = {\n    p: 0,\n    n: 1,\n    b: 2,\n    r: 3,\n    q: 4,\n    k: 5\n  };\n  var FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q'\n  };\n  var BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64\n  };\n  var RANK_1 = 7;\n  var RANK_2 = 6;\n  var RANK_3 = 5;\n  var RANK_4 = 4;\n  var RANK_5 = 3;\n  var RANK_6 = 2;\n  var RANK_7 = 1;\n  var RANK_8 = 0;\n\n  // prettier-ignore\n  var SQUARES = {\n    a8: 0,\n    b8: 1,\n    c8: 2,\n    d8: 3,\n    e8: 4,\n    f8: 5,\n    g8: 6,\n    h8: 7,\n    a7: 16,\n    b7: 17,\n    c7: 18,\n    d7: 19,\n    e7: 20,\n    f7: 21,\n    g7: 22,\n    h7: 23,\n    a6: 32,\n    b6: 33,\n    c6: 34,\n    d6: 35,\n    e6: 36,\n    f6: 37,\n    g6: 38,\n    h6: 39,\n    a5: 48,\n    b5: 49,\n    c5: 50,\n    d5: 51,\n    e5: 52,\n    f5: 53,\n    g5: 54,\n    h5: 55,\n    a4: 64,\n    b4: 65,\n    c4: 66,\n    d4: 67,\n    e4: 68,\n    f4: 69,\n    g4: 70,\n    h4: 71,\n    a3: 80,\n    b3: 81,\n    c3: 82,\n    d3: 83,\n    e3: 84,\n    f3: 85,\n    g3: 86,\n    h3: 87,\n    a2: 96,\n    b2: 97,\n    c2: 98,\n    d2: 99,\n    e2: 100,\n    f2: 101,\n    g2: 102,\n    h2: 103,\n    a1: 112,\n    b1: 113,\n    c1: 114,\n    d1: 115,\n    e1: 116,\n    f1: 117,\n    g1: 118,\n    h1: 119\n  };\n  var ROOKS = {\n    w: [{\n      square: SQUARES.a1,\n      flag: BITS.QSIDE_CASTLE\n    }, {\n      square: SQUARES.h1,\n      flag: BITS.KSIDE_CASTLE\n    }],\n    b: [{\n      square: SQUARES.a8,\n      flag: BITS.QSIDE_CASTLE\n    }, {\n      square: SQUARES.h8,\n      flag: BITS.KSIDE_CASTLE\n    }]\n  };\n  var board = new Array(128);\n  var kings = {\n    w: EMPTY,\n    b: EMPTY\n  };\n  var turn = WHITE;\n  var castling = {\n    w: 0,\n    b: 0\n  };\n  var ep_square = EMPTY;\n  var half_moves = 0;\n  var move_number = 1;\n  var history = [];\n  var header = {};\n  var comments = {};\n\n  /* if the user passes in a fen string, load it, else default to\n   * starting position\n   */\n  if (typeof fen === 'undefined') {\n    load(DEFAULT_POSITION);\n  } else {\n    load(fen);\n  }\n  function clear(keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false;\n    }\n    board = new Array(128);\n    kings = {\n      w: EMPTY,\n      b: EMPTY\n    };\n    turn = WHITE;\n    castling = {\n      w: 0,\n      b: 0\n    };\n    ep_square = EMPTY;\n    half_moves = 0;\n    move_number = 1;\n    history = [];\n    if (!keep_headers) header = {};\n    comments = {};\n    update_setup(generate_fen());\n  }\n  function prune_comments() {\n    var reversed_history = [];\n    var current_comments = {};\n    var copy_comment = function (fen) {\n      if (fen in comments) {\n        current_comments[fen] = comments[fen];\n      }\n    };\n    while (history.length > 0) {\n      reversed_history.push(undo_move());\n    }\n    copy_comment(generate_fen());\n    while (reversed_history.length > 0) {\n      make_move(reversed_history.pop());\n      copy_comment(generate_fen());\n    }\n    comments = current_comments;\n  }\n  function reset() {\n    load(DEFAULT_POSITION);\n  }\n  function load(fen, keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false;\n    }\n    var tokens = fen.split(/\\s+/);\n    var position = tokens[0];\n    var square = 0;\n    if (!validate_fen(fen).valid) {\n      return false;\n    }\n    clear(keep_headers);\n    for (var i = 0; i < position.length; i++) {\n      var piece = position.charAt(i);\n      if (piece === '/') {\n        square += 8;\n      } else if (is_digit(piece)) {\n        square += parseInt(piece, 10);\n      } else {\n        var color = piece < 'a' ? WHITE : BLACK;\n        put({\n          type: piece.toLowerCase(),\n          color: color\n        }, algebraic(square));\n        square++;\n      }\n    }\n    turn = tokens[1];\n    if (tokens[2].indexOf('K') > -1) {\n      castling.w |= BITS.KSIDE_CASTLE;\n    }\n    if (tokens[2].indexOf('Q') > -1) {\n      castling.w |= BITS.QSIDE_CASTLE;\n    }\n    if (tokens[2].indexOf('k') > -1) {\n      castling.b |= BITS.KSIDE_CASTLE;\n    }\n    if (tokens[2].indexOf('q') > -1) {\n      castling.b |= BITS.QSIDE_CASTLE;\n    }\n    ep_square = tokens[3] === '-' ? EMPTY : SQUARES[tokens[3]];\n    half_moves = parseInt(tokens[4], 10);\n    move_number = parseInt(tokens[5], 10);\n    update_setup(generate_fen());\n    return true;\n  }\n\n  /* TODO: this function is pretty much crap - it validates structure but\n   * completely ignores content (e.g. doesn't verify that each side has a king)\n   * ... we should rewrite this, and ditch the silly error_number field while\n   * we're at it\n   */\n  function validate_fen(fen) {\n    var errors = {\n      0: 'No errors.',\n      1: 'FEN string must contain six space-delimited fields.',\n      2: '6th field (move number) must be a positive integer.',\n      3: '5th field (half move counter) must be a non-negative integer.',\n      4: '4th field (en-passant square) is invalid.',\n      5: '3rd field (castling availability) is invalid.',\n      6: '2nd field (side to move) is invalid.',\n      7: \"1st field (piece positions) does not contain 8 '/'-delimited rows.\",\n      8: '1st field (piece positions) is invalid [consecutive numbers].',\n      9: '1st field (piece positions) is invalid [invalid piece].',\n      10: '1st field (piece positions) is invalid [row too large].',\n      11: 'Illegal en-passant square'\n    };\n\n    /* 1st criterion: 6 space-seperated fields? */\n    var tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) {\n      return {\n        valid: false,\n        error_number: 1,\n        error: errors[1]\n      };\n    }\n\n    /* 2nd criterion: move number field is a integer value > 0? */\n    if (isNaN(tokens[5]) || parseInt(tokens[5], 10) <= 0) {\n      return {\n        valid: false,\n        error_number: 2,\n        error: errors[2]\n      };\n    }\n\n    /* 3rd criterion: half move counter is an integer >= 0? */\n    if (isNaN(tokens[4]) || parseInt(tokens[4], 10) < 0) {\n      return {\n        valid: false,\n        error_number: 3,\n        error: errors[3]\n      };\n    }\n\n    /* 4th criterion: 4th field is a valid e.p.-string? */\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n      return {\n        valid: false,\n        error_number: 4,\n        error: errors[4]\n      };\n    }\n\n    /* 5th criterion: 3th field is a valid castle-string? */\n    if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\n      return {\n        valid: false,\n        error_number: 5,\n        error: errors[5]\n      };\n    }\n\n    /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\n    if (!/^(w|b)$/.test(tokens[1])) {\n      return {\n        valid: false,\n        error_number: 6,\n        error: errors[6]\n      };\n    }\n\n    /* 7th criterion: 1st field contains 8 rows? */\n    var rows = tokens[0].split('/');\n    if (rows.length !== 8) {\n      return {\n        valid: false,\n        error_number: 7,\n        error: errors[7]\n      };\n    }\n\n    /* 8th criterion: every row is valid? */\n    for (var i = 0; i < rows.length; i++) {\n      /* check for right sum of fields AND not two numbers in succession */\n      var sum_fields = 0;\n      var previous_was_number = false;\n      for (var k = 0; k < rows[i].length; k++) {\n        if (!isNaN(rows[i][k])) {\n          if (previous_was_number) {\n            return {\n              valid: false,\n              error_number: 8,\n              error: errors[8]\n            };\n          }\n          sum_fields += parseInt(rows[i][k], 10);\n          previous_was_number = true;\n        } else {\n          if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n            return {\n              valid: false,\n              error_number: 9,\n              error: errors[9]\n            };\n          }\n          sum_fields += 1;\n          previous_was_number = false;\n        }\n      }\n      if (sum_fields !== 8) {\n        return {\n          valid: false,\n          error_number: 10,\n          error: errors[10]\n        };\n      }\n    }\n    if (tokens[3][1] == '3' && tokens[1] == 'w' || tokens[3][1] == '6' && tokens[1] == 'b') {\n      return {\n        valid: false,\n        error_number: 11,\n        error: errors[11]\n      };\n    }\n\n    /* everything's okay! */\n    return {\n      valid: true,\n      error_number: 0,\n      error: errors[0]\n    };\n  }\n  function generate_fen() {\n    var empty = 0;\n    var fen = '';\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      if (board[i] == null) {\n        empty++;\n      } else {\n        if (empty > 0) {\n          fen += empty;\n          empty = 0;\n        }\n        var color = board[i].color;\n        var piece = board[i].type;\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n      }\n      if (i + 1 & 0x88) {\n        if (empty > 0) {\n          fen += empty;\n        }\n        if (i !== SQUARES.h1) {\n          fen += '/';\n        }\n        empty = 0;\n        i += 8;\n      }\n    }\n    var cflags = '';\n    if (castling[WHITE] & BITS.KSIDE_CASTLE) {\n      cflags += 'K';\n    }\n    if (castling[WHITE] & BITS.QSIDE_CASTLE) {\n      cflags += 'Q';\n    }\n    if (castling[BLACK] & BITS.KSIDE_CASTLE) {\n      cflags += 'k';\n    }\n    if (castling[BLACK] & BITS.QSIDE_CASTLE) {\n      cflags += 'q';\n    }\n\n    /* do we have an empty castling flag? */\n    cflags = cflags || '-';\n    var epflags = ep_square === EMPTY ? '-' : algebraic(ep_square);\n    return [fen, turn, cflags, epflags, half_moves, move_number].join(' ');\n  }\n  function set_header(args) {\n    for (var i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        header[args[i]] = args[i + 1];\n      }\n    }\n    return header;\n  }\n\n  /* called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object.  if the FEN is\n   * equal to the default position, the SetUp and FEN are deleted\n   * the setup is only updated if history.length is zero, ie moves haven't been\n   * made.\n   */\n  function update_setup(fen) {\n    if (history.length > 0) return;\n    if (fen !== DEFAULT_POSITION) {\n      header['SetUp'] = '1';\n      header['FEN'] = fen;\n    } else {\n      delete header['SetUp'];\n      delete header['FEN'];\n    }\n  }\n  function get(square) {\n    var piece = board[SQUARES[square]];\n    return piece ? {\n      type: piece.type,\n      color: piece.color\n    } : null;\n  }\n  function put(piece, square) {\n    /* check for valid piece object */\n    if (!('type' in piece && 'color' in piece)) {\n      return false;\n    }\n\n    /* check for piece */\n    if (SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {\n      return false;\n    }\n\n    /* check for valid square */\n    if (!(square in SQUARES)) {\n      return false;\n    }\n    var sq = SQUARES[square];\n\n    /* don't let the user place more than one king */\n    if (piece.type == KING && !(kings[piece.color] == EMPTY || kings[piece.color] == sq)) {\n      return false;\n    }\n    board[sq] = {\n      type: piece.type,\n      color: piece.color\n    };\n    if (piece.type === KING) {\n      kings[piece.color] = sq;\n    }\n    update_setup(generate_fen());\n    return true;\n  }\n  function remove(square) {\n    var piece = get(square);\n    board[SQUARES[square]] = null;\n    if (piece && piece.type === KING) {\n      kings[piece.color] = EMPTY;\n    }\n    update_setup(generate_fen());\n    return piece;\n  }\n  function build_move(board, from, to, flags, promotion) {\n    var move = {\n      color: turn,\n      from: from,\n      to: to,\n      flags: flags,\n      piece: board[from].type\n    };\n    if (promotion) {\n      move.flags |= BITS.PROMOTION;\n      move.promotion = promotion;\n    }\n    if (board[to]) {\n      move.captured = board[to].type;\n    } else if (flags & BITS.EP_CAPTURE) {\n      move.captured = PAWN;\n    }\n    return move;\n  }\n  function generate_moves(options) {\n    function add_move(board, moves, from, to, flags) {\n      /* if pawn promotion */\n      if (board[from].type === PAWN && (rank(to) === RANK_8 || rank(to) === RANK_1)) {\n        var pieces = [QUEEN, ROOK, BISHOP, KNIGHT];\n        for (var i = 0, len = pieces.length; i < len; i++) {\n          moves.push(build_move(board, from, to, flags, pieces[i]));\n        }\n      } else {\n        moves.push(build_move(board, from, to, flags));\n      }\n    }\n    var moves = [];\n    var us = turn;\n    var them = swap_color(us);\n    var second_rank = {\n      b: RANK_7,\n      w: RANK_2\n    };\n    var first_sq = SQUARES.a8;\n    var last_sq = SQUARES.h1;\n    var single_square = false;\n\n    /* do we want legal moves? */\n    var legal = typeof options !== 'undefined' && 'legal' in options ? options.legal : true;\n\n    /* are we generating moves for a single square? */\n    if (typeof options !== 'undefined' && 'square' in options) {\n      if (options.square in SQUARES) {\n        first_sq = last_sq = SQUARES[options.square];\n        single_square = true;\n      } else {\n        /* invalid square */\n        return [];\n      }\n    }\n    for (var i = first_sq; i <= last_sq; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n      var piece = board[i];\n      if (piece == null || piece.color !== us) {\n        continue;\n      }\n      if (piece.type === PAWN) {\n        /* single square, non-capturing */\n        var square = i + PAWN_OFFSETS[us][0];\n        if (board[square] == null) {\n          add_move(board, moves, i, square, BITS.NORMAL);\n\n          /* double square */\n          var square = i + PAWN_OFFSETS[us][1];\n          if (second_rank[us] === rank(i) && board[square] == null) {\n            add_move(board, moves, i, square, BITS.BIG_PAWN);\n          }\n        }\n\n        /* pawn captures */\n        for (j = 2; j < 4; j++) {\n          var square = i + PAWN_OFFSETS[us][j];\n          if (square & 0x88) continue;\n          if (board[square] != null && board[square].color === them) {\n            add_move(board, moves, i, square, BITS.CAPTURE);\n          } else if (square === ep_square) {\n            add_move(board, moves, i, ep_square, BITS.EP_CAPTURE);\n          }\n        }\n      } else {\n        for (var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++) {\n          var offset = PIECE_OFFSETS[piece.type][j];\n          var square = i;\n          while (true) {\n            square += offset;\n            if (square & 0x88) break;\n            if (board[square] == null) {\n              add_move(board, moves, i, square, BITS.NORMAL);\n            } else {\n              if (board[square].color === us) break;\n              add_move(board, moves, i, square, BITS.CAPTURE);\n              break;\n            }\n\n            /* break, if knight or king */\n            if (piece.type === 'n' || piece.type === 'k') break;\n          }\n        }\n      }\n    }\n\n    /* check for castling if: a) we're generating all moves, or b) we're doing\n     * single square move generation on the king's square\n     */\n    if (!single_square || last_sq === kings[us]) {\n      /* king-side castling */\n      if (castling[us] & BITS.KSIDE_CASTLE) {\n        var castling_from = kings[us];\n        var castling_to = castling_from + 2;\n        if (board[castling_from + 1] == null && board[castling_to] == null && !attacked(them, kings[us]) && !attacked(them, castling_from + 1) && !attacked(them, castling_to)) {\n          add_move(board, moves, kings[us], castling_to, BITS.KSIDE_CASTLE);\n        }\n      }\n\n      /* queen-side castling */\n      if (castling[us] & BITS.QSIDE_CASTLE) {\n        var castling_from = kings[us];\n        var castling_to = castling_from - 2;\n        if (board[castling_from - 1] == null && board[castling_from - 2] == null && board[castling_from - 3] == null && !attacked(them, kings[us]) && !attacked(them, castling_from - 1) && !attacked(them, castling_to)) {\n          add_move(board, moves, kings[us], castling_to, BITS.QSIDE_CASTLE);\n        }\n      }\n    }\n\n    /* return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n    if (!legal) {\n      return moves;\n    }\n\n    /* filter out illegal moves */\n    var legal_moves = [];\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i]);\n      if (!king_attacked(us)) {\n        legal_moves.push(moves[i]);\n      }\n      undo_move();\n    }\n    return legal_moves;\n  }\n\n  /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} sloppy Use the sloppy SAN generator to work around over\n   * disambiguation bugs in Fritz and Chessbase.  See below:\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n  function move_to_san(move, sloppy) {\n    var output = '';\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O';\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O';\n    } else {\n      var disambiguator = get_disambiguator(move, sloppy);\n      if (move.piece !== PAWN) {\n        output += move.piece.toUpperCase() + disambiguator;\n      }\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0];\n        }\n        output += 'x';\n      }\n      output += algebraic(move.to);\n      if (move.flags & BITS.PROMOTION) {\n        output += '=' + move.promotion.toUpperCase();\n      }\n    }\n    make_move(move);\n    if (in_check()) {\n      if (in_checkmate()) {\n        output += '#';\n      } else {\n        output += '+';\n      }\n    }\n    undo_move();\n    return output;\n  }\n\n  // parses all of the decorators out of a SAN string\n  function stripped_san(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n  }\n  function attacked(color, square) {\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n\n      /* if empty square or wrong color */\n      if (board[i] == null || board[i].color !== color) continue;\n      var piece = board[i];\n      var difference = i - square;\n      var index = difference + 119;\n      if (ATTACKS[index] & 1 << SHIFTS[piece.type]) {\n        if (piece.type === PAWN) {\n          if (difference > 0) {\n            if (piece.color === WHITE) return true;\n          } else {\n            if (piece.color === BLACK) return true;\n          }\n          continue;\n        }\n\n        /* if the piece is a knight or a king */\n        if (piece.type === 'n' || piece.type === 'k') return true;\n        var offset = RAYS[index];\n        var j = i + offset;\n        var blocked = false;\n        while (j !== square) {\n          if (board[j] != null) {\n            blocked = true;\n            break;\n          }\n          j += offset;\n        }\n        if (!blocked) return true;\n      }\n    }\n    return false;\n  }\n  function king_attacked(color) {\n    return attacked(swap_color(color), kings[color]);\n  }\n  function in_check() {\n    return king_attacked(turn);\n  }\n  function in_checkmate() {\n    return in_check() && generate_moves().length === 0;\n  }\n  function in_stalemate() {\n    return !in_check() && generate_moves().length === 0;\n  }\n  function insufficient_material() {\n    var pieces = {};\n    var bishops = [];\n    var num_pieces = 0;\n    var sq_color = 0;\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      sq_color = (sq_color + 1) % 2;\n      if (i & 0x88) {\n        i += 7;\n        continue;\n      }\n      var piece = board[i];\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n        if (piece.type === BISHOP) {\n          bishops.push(sq_color);\n        }\n        num_pieces++;\n      }\n    }\n\n    /* k vs. k */\n    if (num_pieces === 2) {\n      return true;\n    } else if ( /* k vs. kn .... or .... k vs. kb */\n    num_pieces === 3 && (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n      return true;\n    } else if (num_pieces === pieces[BISHOP] + 2) {\n      /* kb vs. kb where any number of bishops are all on the same color */\n      var sum = 0;\n      var len = bishops.length;\n      for (var i = 0; i < len; i++) {\n        sum += bishops[i];\n      }\n      if (sum === 0 || sum === len) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function in_threefold_repetition() {\n    /* TODO: while this function is fine for casual use, a better\n     * implementation would use a Zobrist key (instead of FEN). the\n     * Zobrist key would be maintained in the make_move/undo_move functions,\n     * avoiding the costly that we do below.\n     */\n    var moves = [];\n    var positions = {};\n    var repetition = false;\n    while (true) {\n      var move = undo_move();\n      if (!move) break;\n      moves.push(move);\n    }\n    while (true) {\n      /* remove the last two fields in the FEN string, they're not needed\n       * when checking for draw by rep */\n      var fen = generate_fen().split(' ').slice(0, 4).join(' ');\n\n      /* has the position occurred three or move times */\n      positions[fen] = fen in positions ? positions[fen] + 1 : 1;\n      if (positions[fen] >= 3) {\n        repetition = true;\n      }\n      if (!moves.length) {\n        break;\n      }\n      make_move(moves.pop());\n    }\n    return repetition;\n  }\n  function push(move) {\n    history.push({\n      move: move,\n      kings: {\n        b: kings.b,\n        w: kings.w\n      },\n      turn: turn,\n      castling: {\n        b: castling.b,\n        w: castling.w\n      },\n      ep_square: ep_square,\n      half_moves: half_moves,\n      move_number: move_number\n    });\n  }\n  function make_move(move) {\n    var us = turn;\n    var them = swap_color(us);\n    push(move);\n    board[move.to] = board[move.from];\n    board[move.from] = null;\n\n    /* if ep capture, remove the captured pawn */\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (turn === BLACK) {\n        board[move.to - 16] = null;\n      } else {\n        board[move.to + 16] = null;\n      }\n    }\n\n    /* if pawn promotion, replace with new piece */\n    if (move.flags & BITS.PROMOTION) {\n      board[move.to] = {\n        type: move.promotion,\n        color: us\n      };\n    }\n\n    /* if we moved the king */\n    if (board[move.to].type === KING) {\n      kings[board[move.to].color] = move.to;\n\n      /* if we castled, move the rook next to the king */\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        var castling_to = move.to - 1;\n        var castling_from = move.to + 1;\n        board[castling_to] = board[castling_from];\n        board[castling_from] = null;\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        var castling_to = move.to + 1;\n        var castling_from = move.to - 2;\n        board[castling_to] = board[castling_from];\n        board[castling_from] = null;\n      }\n\n      /* turn off castling */\n      castling[us] = '';\n    }\n\n    /* turn off castling if we move a rook */\n    if (castling[us]) {\n      for (var i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (move.from === ROOKS[us][i].square && castling[us] & ROOKS[us][i].flag) {\n          castling[us] ^= ROOKS[us][i].flag;\n          break;\n        }\n      }\n    }\n\n    /* turn off castling if we capture a rook */\n    if (castling[them]) {\n      for (var i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (move.to === ROOKS[them][i].square && castling[them] & ROOKS[them][i].flag) {\n          castling[them] ^= ROOKS[them][i].flag;\n          break;\n        }\n      }\n    }\n\n    /* if big pawn move, update the en passant square */\n    if (move.flags & BITS.BIG_PAWN) {\n      if (turn === 'b') {\n        ep_square = move.to - 16;\n      } else {\n        ep_square = move.to + 16;\n      }\n    } else {\n      ep_square = EMPTY;\n    }\n\n    /* reset the 50 move counter if a pawn is moved or a piece is captured */\n    if (move.piece === PAWN) {\n      half_moves = 0;\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      half_moves = 0;\n    } else {\n      half_moves++;\n    }\n    if (turn === BLACK) {\n      move_number++;\n    }\n    turn = swap_color(turn);\n  }\n  function undo_move() {\n    var old = history.pop();\n    if (old == null) {\n      return null;\n    }\n    var move = old.move;\n    kings = old.kings;\n    turn = old.turn;\n    castling = old.castling;\n    ep_square = old.ep_square;\n    half_moves = old.half_moves;\n    move_number = old.move_number;\n    var us = turn;\n    var them = swap_color(turn);\n    board[move.from] = board[move.to];\n    board[move.from].type = move.piece; // to undo any promotions\n    board[move.to] = null;\n    if (move.flags & BITS.CAPTURE) {\n      board[move.to] = {\n        type: move.captured,\n        color: them\n      };\n    } else if (move.flags & BITS.EP_CAPTURE) {\n      var index;\n      if (us === BLACK) {\n        index = move.to - 16;\n      } else {\n        index = move.to + 16;\n      }\n      board[index] = {\n        type: PAWN,\n        color: them\n      };\n    }\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      var castling_to, castling_from;\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castling_to = move.to + 1;\n        castling_from = move.to - 1;\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        castling_to = move.to - 2;\n        castling_from = move.to + 1;\n      }\n      board[castling_to] = board[castling_from];\n      board[castling_from] = null;\n    }\n    return move;\n  }\n\n  /* this function is used to uniquely identify ambiguous moves */\n  function get_disambiguator(move, sloppy) {\n    var moves = generate_moves({\n      legal: !sloppy\n    });\n    var from = move.from;\n    var to = move.to;\n    var piece = move.piece;\n    var ambiguities = 0;\n    var same_rank = 0;\n    var same_file = 0;\n    for (var i = 0, len = moves.length; i < len; i++) {\n      var ambig_from = moves[i].from;\n      var ambig_to = moves[i].to;\n      var ambig_piece = moves[i].piece;\n\n      /* if a move of the same piece type ends on the same to square, we'll\n       * need to add a disambiguator to the algebraic notation\n       */\n      if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {\n        ambiguities++;\n        if (rank(from) === rank(ambig_from)) {\n          same_rank++;\n        }\n        if (file(from) === file(ambig_from)) {\n          same_file++;\n        }\n      }\n    }\n    if (ambiguities > 0) {\n      /* if there exists a similar moving piece on the same rank and file as\n       * the move in question, use the square as the disambiguator\n       */\n      if (same_rank > 0 && same_file > 0) {\n        return algebraic(from);\n      } else if (same_file > 0) {\n        /* if the moving piece rests on the same file, use the rank symbol as the\n         * disambiguator\n         */\n        return algebraic(from).charAt(1);\n      } else {\n        /* else use the file symbol */\n        return algebraic(from).charAt(0);\n      }\n    }\n    return '';\n  }\n  function ascii() {\n    var s = '   +------------------------+\\n';\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      /* display the rank */\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |';\n      }\n\n      /* empty piece */\n      if (board[i] == null) {\n        s += ' . ';\n      } else {\n        var piece = board[i].type;\n        var color = board[i].color;\n        var symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n        s += ' ' + symbol + ' ';\n      }\n      if (i + 1 & 0x88) {\n        s += '|\\n';\n        i += 8;\n      }\n    }\n    s += '   +------------------------+\\n';\n    s += '     a  b  c  d  e  f  g  h\\n';\n    return s;\n  }\n\n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n  function move_from_san(move, sloppy) {\n    // strip off any move decorations: e.g Nf3+?!\n    var clean_move = stripped_san(move);\n\n    // if we're using the sloppy parser run a regex to grab piece, to, and from\n    // this should parse invalid SAN like: Pe2-e4, Rc1c4, Qf3xf7\n    if (sloppy) {\n      var matches = clean_move.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n      if (matches) {\n        var piece = matches[1];\n        var from = matches[2];\n        var to = matches[3];\n        var promotion = matches[4];\n      }\n    }\n    var moves = generate_moves();\n    for (var i = 0, len = moves.length; i < len; i++) {\n      // try the strict parser first, then the sloppy parser if requested\n      // by the user\n      if (clean_move === stripped_san(move_to_san(moves[i])) || sloppy && clean_move === stripped_san(move_to_san(moves[i], true))) {\n        return moves[i];\n      } else {\n        if (matches && (!piece || piece.toLowerCase() == moves[i].piece) && SQUARES[from] == moves[i].from && SQUARES[to] == moves[i].to && (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n          return moves[i];\n        }\n      }\n    }\n    return null;\n  }\n\n  /*****************************************************************************\n   * UTILITY FUNCTIONS\n   ****************************************************************************/\n  function rank(i) {\n    return i >> 4;\n  }\n  function file(i) {\n    return i & 15;\n  }\n  function algebraic(i) {\n    var f = file(i),\n      r = rank(i);\n    return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);\n  }\n  function swap_color(c) {\n    return c === WHITE ? BLACK : WHITE;\n  }\n  function is_digit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n  }\n\n  /* pretty = external move object */\n  function make_pretty(ugly_move) {\n    var move = clone(ugly_move);\n    move.san = move_to_san(move, false);\n    move.to = algebraic(move.to);\n    move.from = algebraic(move.from);\n    var flags = '';\n    for (var flag in BITS) {\n      if (BITS[flag] & move.flags) {\n        flags += FLAGS[flag];\n      }\n    }\n    move.flags = flags;\n    return move;\n  }\n  function clone(obj) {\n    var dupe = obj instanceof Array ? [] : {};\n    for (var property in obj) {\n      if (typeof property === 'object') {\n        dupe[property] = clone(obj[property]);\n      } else {\n        dupe[property] = obj[property];\n      }\n    }\n    return dupe;\n  }\n  function trim(str) {\n    return str.replace(/^\\s+|\\s+$/g, '');\n  }\n\n  /*****************************************************************************\n   * DEBUGGING UTILITIES\n   ****************************************************************************/\n  function perft(depth) {\n    var moves = generate_moves({\n      legal: false\n    });\n    var nodes = 0;\n    var color = turn;\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i]);\n      if (!king_attacked(color)) {\n        if (depth - 1 > 0) {\n          var child_nodes = perft(depth - 1);\n          nodes += child_nodes;\n        } else {\n          nodes++;\n        }\n      }\n      undo_move();\n    }\n    return nodes;\n  }\n  return {\n    /***************************************************************************\n     * PUBLIC CONSTANTS (is there a better way to do this?)\n     **************************************************************************/\n    WHITE: WHITE,\n    BLACK: BLACK,\n    PAWN: PAWN,\n    KNIGHT: KNIGHT,\n    BISHOP: BISHOP,\n    ROOK: ROOK,\n    QUEEN: QUEEN,\n    KING: KING,\n    SQUARES: function () {\n      /* from the ECMA-262 spec (section 12.6.4):\n       * \"The mechanics of enumerating the properties ... is\n       * implementation dependent\"\n       * so: for (var sq in SQUARES) { keys.push(sq); } might not be\n       * ordered correctly\n       */\n      var keys = [];\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n        if (i & 0x88) {\n          i += 7;\n          continue;\n        }\n        keys.push(algebraic(i));\n      }\n      return keys;\n    }(),\n    FLAGS: FLAGS,\n    /***************************************************************************\n     * PUBLIC API\n     **************************************************************************/\n    load: function (fen) {\n      return load(fen);\n    },\n    reset: function () {\n      return reset();\n    },\n    moves: function (options) {\n      /* The internal representation of a chess move is in 0x88 format, and\n       * not meant to be human-readable.  The code below converts the 0x88\n       * square coordinates to algebraic coordinates.  It also prunes an\n       * unnecessary move keys resulting from a verbose call.\n       */\n\n      var ugly_moves = generate_moves(options);\n      var moves = [];\n      for (var i = 0, len = ugly_moves.length; i < len; i++) {\n        /* does the user want a full move object (most likely not), or just\n         * SAN\n         */\n        if (typeof options !== 'undefined' && 'verbose' in options && options.verbose) {\n          moves.push(make_pretty(ugly_moves[i]));\n        } else {\n          moves.push(move_to_san(ugly_moves[i], false));\n        }\n      }\n      return moves;\n    },\n    in_check: function () {\n      return in_check();\n    },\n    in_checkmate: function () {\n      return in_checkmate();\n    },\n    in_stalemate: function () {\n      return in_stalemate();\n    },\n    in_draw: function () {\n      return half_moves >= 100 || in_stalemate() || insufficient_material() || in_threefold_repetition();\n    },\n    insufficient_material: function () {\n      return insufficient_material();\n    },\n    in_threefold_repetition: function () {\n      return in_threefold_repetition();\n    },\n    game_over: function () {\n      return half_moves >= 100 || in_checkmate() || in_stalemate() || insufficient_material() || in_threefold_repetition();\n    },\n    validate_fen: function (fen) {\n      return validate_fen(fen);\n    },\n    fen: function () {\n      return generate_fen();\n    },\n    board: function () {\n      var output = [],\n        row = [];\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n        if (board[i] == null) {\n          row.push(null);\n        } else {\n          row.push({\n            type: board[i].type,\n            color: board[i].color\n          });\n        }\n        if (i + 1 & 0x88) {\n          output.push(row);\n          row = [];\n          i += 8;\n        }\n      }\n      return output;\n    },\n    pgn: function (options) {\n      /* using the specification from http://www.chessclub.com/help/PGN-spec\n       * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n       */\n      var newline = typeof options === 'object' && typeof options.newline_char === 'string' ? options.newline_char : '\\n';\n      var max_width = typeof options === 'object' && typeof options.max_width === 'number' ? options.max_width : 0;\n      var result = [];\n      var header_exists = false;\n\n      /* add the PGN header headerrmation */\n      for (var i in header) {\n        /* TODO: order of enumerated properties in header object is not\n         * guaranteed, see ECMA-262 spec (section 12.6.4)\n         */\n        result.push('[' + i + ' \"' + header[i] + '\"]' + newline);\n        header_exists = true;\n      }\n      if (header_exists && history.length) {\n        result.push(newline);\n      }\n      var append_comment = function (move_string) {\n        var comment = comments[generate_fen()];\n        if (typeof comment !== 'undefined') {\n          var delimiter = move_string.length > 0 ? ' ' : '';\n          move_string = `${move_string}${delimiter}{${comment}}`;\n        }\n        return move_string;\n      };\n\n      /* pop all of history onto reversed_history */\n      var reversed_history = [];\n      while (history.length > 0) {\n        reversed_history.push(undo_move());\n      }\n      var moves = [];\n      var move_string = '';\n\n      /* special case of a commented starting position with no moves */\n      if (reversed_history.length === 0) {\n        moves.push(append_comment(''));\n      }\n\n      /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\n      while (reversed_history.length > 0) {\n        move_string = append_comment(move_string);\n        var move = reversed_history.pop();\n\n        /* if the position started with black to move, start PGN with 1. ... */\n        if (!history.length && move.color === 'b') {\n          move_string = move_number + '. ...';\n        } else if (move.color === 'w') {\n          /* store the previous generated move_string if we have one */\n          if (move_string.length) {\n            moves.push(move_string);\n          }\n          move_string = move_number + '.';\n        }\n        move_string = move_string + ' ' + move_to_san(move, false);\n        make_move(move);\n      }\n\n      /* are there any other leftover moves? */\n      if (move_string.length) {\n        moves.push(append_comment(move_string));\n      }\n\n      /* is there a result? */\n      if (typeof header.Result !== 'undefined') {\n        moves.push(header.Result);\n      }\n\n      /* history should be back to what it was before we started generating PGN,\n       * so join together moves\n       */\n      if (max_width === 0) {\n        return result.join('') + moves.join(' ');\n      }\n      var strip = function () {\n        if (result.length > 0 && result[result.length - 1] === ' ') {\n          result.pop();\n          return true;\n        }\n        return false;\n      };\n\n      /* NB: this does not preserve comment whitespace. */\n      var wrap_comment = function (width, move) {\n        for (var token of move.split(' ')) {\n          if (!token) {\n            continue;\n          }\n          if (width + token.length > max_width) {\n            while (strip()) {\n              width--;\n            }\n            result.push(newline);\n            width = 0;\n          }\n          result.push(token);\n          width += token.length;\n          result.push(' ');\n          width++;\n        }\n        if (strip()) {\n          width--;\n        }\n        return width;\n      };\n\n      /* wrap the PGN output at max_width */\n      var current_width = 0;\n      for (var i = 0; i < moves.length; i++) {\n        if (current_width + moves[i].length > max_width) {\n          if (moves[i].includes('{')) {\n            current_width = wrap_comment(current_width, moves[i]);\n            continue;\n          }\n        }\n        /* if the current move will push past max_width */\n        if (current_width + moves[i].length > max_width && i !== 0) {\n          /* don't end the line with whitespace */\n          if (result[result.length - 1] === ' ') {\n            result.pop();\n          }\n          result.push(newline);\n          current_width = 0;\n        } else if (i !== 0) {\n          result.push(' ');\n          current_width++;\n        }\n        result.push(moves[i]);\n        current_width += moves[i].length;\n      }\n      return result.join('');\n    },\n    load_pgn: function (pgn, options) {\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy = typeof options !== 'undefined' && 'sloppy' in options ? options.sloppy : false;\n      function mask(str) {\n        return str.replace(/\\\\/g, '\\\\');\n      }\n      function has_keys(object) {\n        for (var key in object) {\n          return true;\n        }\n        return false;\n      }\n      function parse_pgn_header(header, options) {\n        var newline_char = typeof options === 'object' && typeof options.newline_char === 'string' ? options.newline_char : '\\r?\\n';\n        var header_obj = {};\n        var headers = header.split(new RegExp(mask(newline_char)));\n        var key = '';\n        var value = '';\n        for (var i = 0; i < headers.length; i++) {\n          key = headers[i].replace(/^\\[([A-Z][A-Za-z]*)\\s.*\\]$/, '$1');\n          value = headers[i].replace(/^\\[[A-Za-z]+\\s\"(.*)\"\\ *\\]$/, '$1');\n          if (trim(key).length > 0) {\n            header_obj[key] = value;\n          }\n        }\n        return header_obj;\n      }\n      var newline_char = typeof options === 'object' && typeof options.newline_char === 'string' ? options.newline_char : '\\r?\\n';\n\n      // RegExp to split header. Takes advantage of the fact that header and movetext\n      // will always have a blank line between them (ie, two newline_char's).\n      // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\r?\\n){2}/\n      var header_regex = new RegExp('^(\\\\[((?:' + mask(newline_char) + ')|.)*\\\\])' + '(?:' + mask(newline_char) + '){2}');\n\n      // If no header given, begin with moves.\n      var header_string = header_regex.test(pgn) ? header_regex.exec(pgn)[1] : '';\n\n      // Put the board in the starting position\n      reset();\n\n      /* parse PGN header */\n      var headers = parse_pgn_header(header_string, options);\n      for (var key in headers) {\n        set_header([key, headers[key]]);\n      }\n\n      /* load the starting position indicated by [Setup '1'] and\n       * [FEN position] */\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers && load(headers['FEN'], true))) {\n          // second argument to load: don't clear the headers\n          return false;\n        }\n      }\n\n      /* NB: the regexes below that delete move numbers, recursive\n       * annotations, and numeric annotation glyphs may also match\n       * text in comments. To prevent this, we transform comments\n       * by hex-encoding them in place and decoding them again after\n       * the other tokens have been deleted.\n       *\n       * While the spec states that PGN files should be ASCII encoded,\n       * we use {en,de}codeURIComponent here to support arbitrary UTF8\n       * as a convenience for modern users */\n\n      var to_hex = function (string) {\n        return Array.from(string).map(function (c) {\n          /* encodeURI doesn't transform most ASCII characters,\n           * so we handle these ourselves */\n          return c.charCodeAt(0) < 128 ? c.charCodeAt(0).toString(16) : encodeURIComponent(c).replace(/\\%/g, '').toLowerCase();\n        }).join('');\n      };\n      var from_hex = function (string) {\n        return string.length == 0 ? '' : decodeURIComponent('%' + string.match(/.{1,2}/g).join('%'));\n      };\n      var encode_comment = function (string) {\n        string = string.replace(new RegExp(mask(newline_char), 'g'), ' ');\n        return `{${to_hex(string.slice(1, string.length - 1))}}`;\n      };\n      var decode_comment = function (string) {\n        if (string.startsWith('{') && string.endsWith('}')) {\n          return from_hex(string.slice(1, string.length - 1));\n        }\n      };\n\n      /* delete header to get the moves */\n      var ms = pgn.replace(header_string, '').replace( /* encode comments so they don't get deleted below */\n      new RegExp(`(\\{[^}]*\\})+?|;([^${mask(newline_char)}]*)`, 'g'), function (match, bracket, semicolon) {\n        return bracket !== undefined ? encode_comment(bracket) : ' ' + encode_comment(`{${semicolon.slice(1)}}`);\n      }).replace(new RegExp(mask(newline_char), 'g'), ' ');\n\n      /* delete recursive annotation variations */\n      var rav_regex = /(\\([^\\(\\)]+\\))+?/g;\n      while (rav_regex.test(ms)) {\n        ms = ms.replace(rav_regex, '');\n      }\n\n      /* delete move numbers */\n      ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n\n      /* delete ... indicating black to move */\n      ms = ms.replace(/\\.\\.\\./g, '');\n\n      /* delete numeric annotation glyphs */\n      ms = ms.replace(/\\$\\d+/g, '');\n\n      /* trim and get array of moves */\n      var moves = trim(ms).split(new RegExp(/\\s+/));\n\n      /* delete empty entries */\n      moves = moves.join(',').replace(/,,+/g, ',').split(',');\n      var move = '';\n      for (var half_move = 0; half_move < moves.length - 1; half_move++) {\n        var comment = decode_comment(moves[half_move]);\n        if (comment !== undefined) {\n          comments[generate_fen()] = comment;\n          continue;\n        }\n        move = move_from_san(moves[half_move], sloppy);\n\n        /* move not possible! (don't clear the board to examine to show the\n         * latest valid position)\n         */\n        if (move == null) {\n          return false;\n        } else {\n          make_move(move);\n        }\n      }\n      comment = decode_comment(moves[moves.length - 1]);\n      if (comment !== undefined) {\n        comments[generate_fen()] = comment;\n        moves.pop();\n      }\n\n      /* examine last move */\n      move = moves[moves.length - 1];\n      if (POSSIBLE_RESULTS.indexOf(move) > -1) {\n        if (has_keys(header) && typeof header.Result === 'undefined') {\n          set_header(['Result', move]);\n        }\n      } else {\n        move = move_from_san(move, sloppy);\n        if (move == null) {\n          return false;\n        } else {\n          make_move(move);\n        }\n      }\n      return true;\n    },\n    header: function () {\n      return set_header(arguments);\n    },\n    ascii: function () {\n      return ascii();\n    },\n    turn: function () {\n      return turn;\n    },\n    move: function (move, options) {\n      /* The move function can be called with in the following parameters:\n       *\n       * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\n       *\n       * .move({ from: 'h7', <- where the 'move' is a move object (additional\n       *         to :'h8',      fields are ignored)\n       *         promotion: 'q',\n       *      })\n       */\n\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy = typeof options !== 'undefined' && 'sloppy' in options ? options.sloppy : false;\n      var move_obj = null;\n      if (typeof move === 'string') {\n        move_obj = move_from_san(move, sloppy);\n      } else if (typeof move === 'object') {\n        var moves = generate_moves();\n\n        /* convert the pretty move object to an ugly move object */\n        for (var i = 0, len = moves.length; i < len; i++) {\n          if (move.from === algebraic(moves[i].from) && move.to === algebraic(moves[i].to) && (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n            move_obj = moves[i];\n            break;\n          }\n        }\n      }\n\n      /* failed to find move */\n      if (!move_obj) {\n        return null;\n      }\n\n      /* need to make a copy of move because we can't generate SAN after the\n       * move is made\n       */\n      var pretty_move = make_pretty(move_obj);\n      make_move(move_obj);\n      return pretty_move;\n    },\n    undo: function () {\n      var move = undo_move();\n      return move ? make_pretty(move) : null;\n    },\n    clear: function () {\n      return clear();\n    },\n    put: function (piece, square) {\n      return put(piece, square);\n    },\n    get: function (square) {\n      return get(square);\n    },\n    remove: function (square) {\n      return remove(square);\n    },\n    perft: function (depth) {\n      return perft(depth);\n    },\n    square_color: function (square) {\n      if (square in SQUARES) {\n        var sq_0x88 = SQUARES[square];\n        return (rank(sq_0x88) + file(sq_0x88)) % 2 === 0 ? 'light' : 'dark';\n      }\n      return null;\n    },\n    history: function (options) {\n      var reversed_history = [];\n      var move_history = [];\n      var verbose = typeof options !== 'undefined' && 'verbose' in options && options.verbose;\n      while (history.length > 0) {\n        reversed_history.push(undo_move());\n      }\n      while (reversed_history.length > 0) {\n        var move = reversed_history.pop();\n        if (verbose) {\n          move_history.push(make_pretty(move));\n        } else {\n          move_history.push(move_to_san(move));\n        }\n        make_move(move);\n      }\n      return move_history;\n    },\n    get_comment: function () {\n      return comments[generate_fen()];\n    },\n    set_comment: function (comment) {\n      comments[generate_fen()] = comment.replace('{', '[').replace('}', ']');\n    },\n    delete_comment: function () {\n      var comment = comments[generate_fen()];\n      delete comments[generate_fen()];\n      return comment;\n    },\n    get_comments: function () {\n      prune_comments();\n      return Object.keys(comments).map(function (fen) {\n        return {\n          fen: fen,\n          comment: comments[fen]\n        };\n      });\n    },\n    delete_comments: function () {\n      prune_comments();\n      return Object.keys(comments).map(function (fen) {\n        var comment = comments[fen];\n        delete comments[fen];\n        return {\n          fen: fen,\n          comment: comment\n        };\n      });\n    }\n  };\n};\n\n/* export Chess object if using node or any other CommonJS compatible\n * environment */\nif (typeof exports !== 'undefined') exports.Chess = Chess;\n/* export Chess object for any RequireJS compatible environment */\nif (typeof define !== 'undefined') define(function () {\n  return Chess;\n});","map":{"version":3,"names":["Chess","fen","BLACK","WHITE","EMPTY","PAWN","KNIGHT","BISHOP","ROOK","QUEEN","KING","SYMBOLS","DEFAULT_POSITION","POSSIBLE_RESULTS","PAWN_OFFSETS","b","w","PIECE_OFFSETS","n","r","q","k","ATTACKS","RAYS","SHIFTS","p","FLAGS","NORMAL","CAPTURE","BIG_PAWN","EP_CAPTURE","PROMOTION","KSIDE_CASTLE","QSIDE_CASTLE","BITS","RANK_1","RANK_2","RANK_3","RANK_4","RANK_5","RANK_6","RANK_7","RANK_8","SQUARES","a8","b8","c8","d8","e8","f8","g8","h8","a7","b7","c7","d7","e7","f7","g7","h7","a6","b6","c6","d6","e6","f6","g6","h6","a5","b5","c5","d5","e5","f5","g5","h5","a4","b4","c4","d4","e4","f4","g4","h4","a3","b3","c3","d3","e3","f3","g3","h3","a2","b2","c2","d2","e2","f2","g2","h2","a1","b1","c1","d1","e1","f1","g1","h1","ROOKS","square","flag","board","Array","kings","turn","castling","ep_square","half_moves","move_number","history","header","comments","load","clear","keep_headers","update_setup","generate_fen","prune_comments","reversed_history","current_comments","copy_comment","length","push","undo_move","make_move","pop","reset","tokens","split","position","validate_fen","valid","i","piece","charAt","is_digit","parseInt","color","put","type","toLowerCase","algebraic","indexOf","errors","error_number","error","isNaN","test","rows","sum_fields","previous_was_number","empty","toUpperCase","cflags","epflags","join","set_header","args","get","sq","remove","build_move","from","to","flags","promotion","move","captured","generate_moves","options","add_move","moves","rank","pieces","len","us","them","swap_color","second_rank","first_sq","last_sq","single_square","legal","j","offset","castling_from","castling_to","attacked","legal_moves","king_attacked","move_to_san","sloppy","output","disambiguator","get_disambiguator","in_check","in_checkmate","stripped_san","replace","difference","index","blocked","in_stalemate","insufficient_material","bishops","num_pieces","sq_color","sum","in_threefold_repetition","positions","repetition","slice","old","ambiguities","same_rank","same_file","ambig_from","ambig_to","ambig_piece","file","ascii","s","symbol","move_from_san","clean_move","matches","match","f","substring","c","make_pretty","ugly_move","clone","san","obj","dupe","property","trim","str","perft","depth","nodes","child_nodes","keys","ugly_moves","verbose","in_draw","game_over","row","pgn","newline","newline_char","max_width","result","header_exists","append_comment","move_string","comment","delimiter","Result","strip","wrap_comment","width","token","current_width","includes","load_pgn","mask","has_keys","object","key","parse_pgn_header","header_obj","headers","RegExp","value","header_regex","header_string","exec","to_hex","string","map","charCodeAt","toString","encodeURIComponent","from_hex","decodeURIComponent","encode_comment","decode_comment","startsWith","endsWith","ms","bracket","semicolon","undefined","rav_regex","half_move","arguments","move_obj","pretty_move","undo","square_color","sq_0x88","move_history","get_comment","set_comment","delete_comment","get_comments","Object","delete_comments","exports","define"],"sources":["C:/Users/ASUS/OneDrive/Documentos/UTJ/6-A/Estadias/Ajedrez/react-chess-feature-online/node_modules/chess.js/chess.js"],"sourcesContent":["/*\n * Copyright (c) 2020, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n *----------------------------------------------------------------------------*/\n\nvar Chess = function(fen) {\n  var BLACK = 'b'\n  var WHITE = 'w'\n\n  var EMPTY = -1\n\n  var PAWN = 'p'\n  var KNIGHT = 'n'\n  var BISHOP = 'b'\n  var ROOK = 'r'\n  var QUEEN = 'q'\n  var KING = 'k'\n\n  var SYMBOLS = 'pnbrqkPNBRQK'\n\n  var DEFAULT_POSITION =\n    'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\n\n  var POSSIBLE_RESULTS = ['1-0', '0-1', '1/2-1/2', '*']\n\n  var PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15]\n  }\n\n  var PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1]\n  }\n\n  // prettier-ignore\n  var ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,\n     0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n     0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n     0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n     0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,\n     0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n     0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n     0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n     0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20\n  ];\n\n  // prettier-ignore\n  var RAYS = [\n     17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,\n      0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,\n      0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,\n      0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,\n      0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,\n      0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,\n      0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,\n      1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,\n      0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,\n      0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,\n      0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,\n      0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,\n      0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,\n      0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,\n    -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17\n  ];\n\n  var SHIFTS = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 }\n\n  var FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q'\n  }\n\n  var BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64\n  }\n\n  var RANK_1 = 7\n  var RANK_2 = 6\n  var RANK_3 = 5\n  var RANK_4 = 4\n  var RANK_5 = 3\n  var RANK_6 = 2\n  var RANK_7 = 1\n  var RANK_8 = 0\n\n  // prettier-ignore\n  var SQUARES = {\n    a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,\n    a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,\n    a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,\n    a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,\n    a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,\n    a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,\n    a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n  };\n\n  var ROOKS = {\n    w: [\n      { square: SQUARES.a1, flag: BITS.QSIDE_CASTLE },\n      { square: SQUARES.h1, flag: BITS.KSIDE_CASTLE }\n    ],\n    b: [\n      { square: SQUARES.a8, flag: BITS.QSIDE_CASTLE },\n      { square: SQUARES.h8, flag: BITS.KSIDE_CASTLE }\n    ]\n  }\n\n  var board = new Array(128)\n  var kings = { w: EMPTY, b: EMPTY }\n  var turn = WHITE\n  var castling = { w: 0, b: 0 }\n  var ep_square = EMPTY\n  var half_moves = 0\n  var move_number = 1\n  var history = []\n  var header = {}\n  var comments = {}\n\n  /* if the user passes in a fen string, load it, else default to\n   * starting position\n   */\n  if (typeof fen === 'undefined') {\n    load(DEFAULT_POSITION)\n  } else {\n    load(fen)\n  }\n\n  function clear(keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false\n    }\n\n    board = new Array(128)\n    kings = { w: EMPTY, b: EMPTY }\n    turn = WHITE\n    castling = { w: 0, b: 0 }\n    ep_square = EMPTY\n    half_moves = 0\n    move_number = 1\n    history = []\n    if (!keep_headers) header = {}\n    comments = {}\n    update_setup(generate_fen())\n  }\n\n  function prune_comments() {\n    var reversed_history = [];\n    var current_comments = {};\n    var copy_comment = function(fen) {\n      if (fen in comments) {\n        current_comments[fen] = comments[fen];\n      }\n    };\n    while (history.length > 0) {\n      reversed_history.push(undo_move());\n    }\n    copy_comment(generate_fen());\n    while (reversed_history.length > 0) {\n      make_move(reversed_history.pop());\n      copy_comment(generate_fen());\n    }\n    comments = current_comments;\n  }\n\n  function reset() {\n    load(DEFAULT_POSITION)\n  }\n\n  function load(fen, keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false\n    }\n\n    var tokens = fen.split(/\\s+/)\n    var position = tokens[0]\n    var square = 0\n\n    if (!validate_fen(fen).valid) {\n      return false\n    }\n\n    clear(keep_headers)\n\n    for (var i = 0; i < position.length; i++) {\n      var piece = position.charAt(i)\n\n      if (piece === '/') {\n        square += 8\n      } else if (is_digit(piece)) {\n        square += parseInt(piece, 10)\n      } else {\n        var color = piece < 'a' ? WHITE : BLACK\n        put({ type: piece.toLowerCase(), color: color }, algebraic(square))\n        square++\n      }\n    }\n\n    turn = tokens[1]\n\n    if (tokens[2].indexOf('K') > -1) {\n      castling.w |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('Q') > -1) {\n      castling.w |= BITS.QSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('k') > -1) {\n      castling.b |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('q') > -1) {\n      castling.b |= BITS.QSIDE_CASTLE\n    }\n\n    ep_square = tokens[3] === '-' ? EMPTY : SQUARES[tokens[3]]\n    half_moves = parseInt(tokens[4], 10)\n    move_number = parseInt(tokens[5], 10)\n\n    update_setup(generate_fen())\n\n    return true\n  }\n\n  /* TODO: this function is pretty much crap - it validates structure but\n   * completely ignores content (e.g. doesn't verify that each side has a king)\n   * ... we should rewrite this, and ditch the silly error_number field while\n   * we're at it\n   */\n  function validate_fen(fen) {\n    var errors = {\n      0: 'No errors.',\n      1: 'FEN string must contain six space-delimited fields.',\n      2: '6th field (move number) must be a positive integer.',\n      3: '5th field (half move counter) must be a non-negative integer.',\n      4: '4th field (en-passant square) is invalid.',\n      5: '3rd field (castling availability) is invalid.',\n      6: '2nd field (side to move) is invalid.',\n      7: \"1st field (piece positions) does not contain 8 '/'-delimited rows.\",\n      8: '1st field (piece positions) is invalid [consecutive numbers].',\n      9: '1st field (piece positions) is invalid [invalid piece].',\n      10: '1st field (piece positions) is invalid [row too large].',\n      11: 'Illegal en-passant square'\n    }\n\n    /* 1st criterion: 6 space-seperated fields? */\n    var tokens = fen.split(/\\s+/)\n    if (tokens.length !== 6) {\n      return { valid: false, error_number: 1, error: errors[1] }\n    }\n\n    /* 2nd criterion: move number field is a integer value > 0? */\n    if (isNaN(tokens[5]) || parseInt(tokens[5], 10) <= 0) {\n      return { valid: false, error_number: 2, error: errors[2] }\n    }\n\n    /* 3rd criterion: half move counter is an integer >= 0? */\n    if (isNaN(tokens[4]) || parseInt(tokens[4], 10) < 0) {\n      return { valid: false, error_number: 3, error: errors[3] }\n    }\n\n    /* 4th criterion: 4th field is a valid e.p.-string? */\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n      return { valid: false, error_number: 4, error: errors[4] }\n    }\n\n    /* 5th criterion: 3th field is a valid castle-string? */\n    if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\n      return { valid: false, error_number: 5, error: errors[5] }\n    }\n\n    /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\n    if (!/^(w|b)$/.test(tokens[1])) {\n      return { valid: false, error_number: 6, error: errors[6] }\n    }\n\n    /* 7th criterion: 1st field contains 8 rows? */\n    var rows = tokens[0].split('/')\n    if (rows.length !== 8) {\n      return { valid: false, error_number: 7, error: errors[7] }\n    }\n\n    /* 8th criterion: every row is valid? */\n    for (var i = 0; i < rows.length; i++) {\n      /* check for right sum of fields AND not two numbers in succession */\n      var sum_fields = 0\n      var previous_was_number = false\n\n      for (var k = 0; k < rows[i].length; k++) {\n        if (!isNaN(rows[i][k])) {\n          if (previous_was_number) {\n            return { valid: false, error_number: 8, error: errors[8] }\n          }\n          sum_fields += parseInt(rows[i][k], 10)\n          previous_was_number = true\n        } else {\n          if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n            return { valid: false, error_number: 9, error: errors[9] }\n          }\n          sum_fields += 1\n          previous_was_number = false\n        }\n      }\n      if (sum_fields !== 8) {\n        return { valid: false, error_number: 10, error: errors[10] }\n      }\n    }\n\n    if (\n      (tokens[3][1] == '3' && tokens[1] == 'w') ||\n      (tokens[3][1] == '6' && tokens[1] == 'b')\n    ) {\n      return { valid: false, error_number: 11, error: errors[11] }\n    }\n\n    /* everything's okay! */\n    return { valid: true, error_number: 0, error: errors[0] }\n  }\n\n  function generate_fen() {\n    var empty = 0\n    var fen = ''\n\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      if (board[i] == null) {\n        empty++\n      } else {\n        if (empty > 0) {\n          fen += empty\n          empty = 0\n        }\n        var color = board[i].color\n        var piece = board[i].type\n\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n      }\n\n      if ((i + 1) & 0x88) {\n        if (empty > 0) {\n          fen += empty\n        }\n\n        if (i !== SQUARES.h1) {\n          fen += '/'\n        }\n\n        empty = 0\n        i += 8\n      }\n    }\n\n    var cflags = ''\n    if (castling[WHITE] & BITS.KSIDE_CASTLE) {\n      cflags += 'K'\n    }\n    if (castling[WHITE] & BITS.QSIDE_CASTLE) {\n      cflags += 'Q'\n    }\n    if (castling[BLACK] & BITS.KSIDE_CASTLE) {\n      cflags += 'k'\n    }\n    if (castling[BLACK] & BITS.QSIDE_CASTLE) {\n      cflags += 'q'\n    }\n\n    /* do we have an empty castling flag? */\n    cflags = cflags || '-'\n    var epflags = ep_square === EMPTY ? '-' : algebraic(ep_square)\n\n    return [fen, turn, cflags, epflags, half_moves, move_number].join(' ')\n  }\n\n  function set_header(args) {\n    for (var i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        header[args[i]] = args[i + 1]\n      }\n    }\n    return header\n  }\n\n  /* called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object.  if the FEN is\n   * equal to the default position, the SetUp and FEN are deleted\n   * the setup is only updated if history.length is zero, ie moves haven't been\n   * made.\n   */\n  function update_setup(fen) {\n    if (history.length > 0) return\n\n    if (fen !== DEFAULT_POSITION) {\n      header['SetUp'] = '1'\n      header['FEN'] = fen\n    } else {\n      delete header['SetUp']\n      delete header['FEN']\n    }\n  }\n\n  function get(square) {\n    var piece = board[SQUARES[square]]\n    return piece ? { type: piece.type, color: piece.color } : null\n  }\n\n  function put(piece, square) {\n    /* check for valid piece object */\n    if (!('type' in piece && 'color' in piece)) {\n      return false\n    }\n\n    /* check for piece */\n    if (SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {\n      return false\n    }\n\n    /* check for valid square */\n    if (!(square in SQUARES)) {\n      return false\n    }\n\n    var sq = SQUARES[square]\n\n    /* don't let the user place more than one king */\n    if (\n      piece.type == KING &&\n      !(kings[piece.color] == EMPTY || kings[piece.color] == sq)\n    ) {\n      return false\n    }\n\n    board[sq] = { type: piece.type, color: piece.color }\n    if (piece.type === KING) {\n      kings[piece.color] = sq\n    }\n\n    update_setup(generate_fen())\n\n    return true\n  }\n\n  function remove(square) {\n    var piece = get(square)\n    board[SQUARES[square]] = null\n    if (piece && piece.type === KING) {\n      kings[piece.color] = EMPTY\n    }\n\n    update_setup(generate_fen())\n\n    return piece\n  }\n\n  function build_move(board, from, to, flags, promotion) {\n    var move = {\n      color: turn,\n      from: from,\n      to: to,\n      flags: flags,\n      piece: board[from].type\n    }\n\n    if (promotion) {\n      move.flags |= BITS.PROMOTION\n      move.promotion = promotion\n    }\n\n    if (board[to]) {\n      move.captured = board[to].type\n    } else if (flags & BITS.EP_CAPTURE) {\n      move.captured = PAWN\n    }\n    return move\n  }\n\n  function generate_moves(options) {\n    function add_move(board, moves, from, to, flags) {\n      /* if pawn promotion */\n      if (\n        board[from].type === PAWN &&\n        (rank(to) === RANK_8 || rank(to) === RANK_1)\n      ) {\n        var pieces = [QUEEN, ROOK, BISHOP, KNIGHT]\n        for (var i = 0, len = pieces.length; i < len; i++) {\n          moves.push(build_move(board, from, to, flags, pieces[i]))\n        }\n      } else {\n        moves.push(build_move(board, from, to, flags))\n      }\n    }\n\n    var moves = []\n    var us = turn\n    var them = swap_color(us)\n    var second_rank = { b: RANK_7, w: RANK_2 }\n\n    var first_sq = SQUARES.a8\n    var last_sq = SQUARES.h1\n    var single_square = false\n\n    /* do we want legal moves? */\n    var legal =\n      typeof options !== 'undefined' && 'legal' in options\n        ? options.legal\n        : true\n\n    /* are we generating moves for a single square? */\n    if (typeof options !== 'undefined' && 'square' in options) {\n      if (options.square in SQUARES) {\n        first_sq = last_sq = SQUARES[options.square]\n        single_square = true\n      } else {\n        /* invalid square */\n        return []\n      }\n    }\n\n    for (var i = first_sq; i <= last_sq; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      var piece = board[i]\n      if (piece == null || piece.color !== us) {\n        continue\n      }\n\n      if (piece.type === PAWN) {\n        /* single square, non-capturing */\n        var square = i + PAWN_OFFSETS[us][0]\n        if (board[square] == null) {\n          add_move(board, moves, i, square, BITS.NORMAL)\n\n          /* double square */\n          var square = i + PAWN_OFFSETS[us][1]\n          if (second_rank[us] === rank(i) && board[square] == null) {\n            add_move(board, moves, i, square, BITS.BIG_PAWN)\n          }\n        }\n\n        /* pawn captures */\n        for (j = 2; j < 4; j++) {\n          var square = i + PAWN_OFFSETS[us][j]\n          if (square & 0x88) continue\n\n          if (board[square] != null && board[square].color === them) {\n            add_move(board, moves, i, square, BITS.CAPTURE)\n          } else if (square === ep_square) {\n            add_move(board, moves, i, ep_square, BITS.EP_CAPTURE)\n          }\n        }\n      } else {\n        for (var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++) {\n          var offset = PIECE_OFFSETS[piece.type][j]\n          var square = i\n\n          while (true) {\n            square += offset\n            if (square & 0x88) break\n\n            if (board[square] == null) {\n              add_move(board, moves, i, square, BITS.NORMAL)\n            } else {\n              if (board[square].color === us) break\n              add_move(board, moves, i, square, BITS.CAPTURE)\n              break\n            }\n\n            /* break, if knight or king */\n            if (piece.type === 'n' || piece.type === 'k') break\n          }\n        }\n      }\n    }\n\n    /* check for castling if: a) we're generating all moves, or b) we're doing\n     * single square move generation on the king's square\n     */\n    if (!single_square || last_sq === kings[us]) {\n      /* king-side castling */\n      if (castling[us] & BITS.KSIDE_CASTLE) {\n        var castling_from = kings[us]\n        var castling_to = castling_from + 2\n\n        if (\n          board[castling_from + 1] == null &&\n          board[castling_to] == null &&\n          !attacked(them, kings[us]) &&\n          !attacked(them, castling_from + 1) &&\n          !attacked(them, castling_to)\n        ) {\n          add_move(board, moves, kings[us], castling_to, BITS.KSIDE_CASTLE)\n        }\n      }\n\n      /* queen-side castling */\n      if (castling[us] & BITS.QSIDE_CASTLE) {\n        var castling_from = kings[us]\n        var castling_to = castling_from - 2\n\n        if (\n          board[castling_from - 1] == null &&\n          board[castling_from - 2] == null &&\n          board[castling_from - 3] == null &&\n          !attacked(them, kings[us]) &&\n          !attacked(them, castling_from - 1) &&\n          !attacked(them, castling_to)\n        ) {\n          add_move(board, moves, kings[us], castling_to, BITS.QSIDE_CASTLE)\n        }\n      }\n    }\n\n    /* return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n    if (!legal) {\n      return moves\n    }\n\n    /* filter out illegal moves */\n    var legal_moves = []\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i])\n      if (!king_attacked(us)) {\n        legal_moves.push(moves[i])\n      }\n      undo_move()\n    }\n\n    return legal_moves\n  }\n\n  /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} sloppy Use the sloppy SAN generator to work around over\n   * disambiguation bugs in Fritz and Chessbase.  See below:\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n  function move_to_san(move, sloppy) {\n    var output = ''\n\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O'\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O'\n    } else {\n      var disambiguator = get_disambiguator(move, sloppy)\n\n      if (move.piece !== PAWN) {\n        output += move.piece.toUpperCase() + disambiguator\n      }\n\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0]\n        }\n        output += 'x'\n      }\n\n      output += algebraic(move.to)\n\n      if (move.flags & BITS.PROMOTION) {\n        output += '=' + move.promotion.toUpperCase()\n      }\n    }\n\n    make_move(move)\n    if (in_check()) {\n      if (in_checkmate()) {\n        output += '#'\n      } else {\n        output += '+'\n      }\n    }\n    undo_move()\n\n    return output\n  }\n\n  // parses all of the decorators out of a SAN string\n  function stripped_san(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\n  }\n\n  function attacked(color, square) {\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      /* if empty square or wrong color */\n      if (board[i] == null || board[i].color !== color) continue\n\n      var piece = board[i]\n      var difference = i - square\n      var index = difference + 119\n\n      if (ATTACKS[index] & (1 << SHIFTS[piece.type])) {\n        if (piece.type === PAWN) {\n          if (difference > 0) {\n            if (piece.color === WHITE) return true\n          } else {\n            if (piece.color === BLACK) return true\n          }\n          continue\n        }\n\n        /* if the piece is a knight or a king */\n        if (piece.type === 'n' || piece.type === 'k') return true\n\n        var offset = RAYS[index]\n        var j = i + offset\n\n        var blocked = false\n        while (j !== square) {\n          if (board[j] != null) {\n            blocked = true\n            break\n          }\n          j += offset\n        }\n\n        if (!blocked) return true\n      }\n    }\n\n    return false\n  }\n\n  function king_attacked(color) {\n    return attacked(swap_color(color), kings[color])\n  }\n\n  function in_check() {\n    return king_attacked(turn)\n  }\n\n  function in_checkmate() {\n    return in_check() && generate_moves().length === 0\n  }\n\n  function in_stalemate() {\n    return !in_check() && generate_moves().length === 0\n  }\n\n  function insufficient_material() {\n    var pieces = {}\n    var bishops = []\n    var num_pieces = 0\n    var sq_color = 0\n\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      sq_color = (sq_color + 1) % 2\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      var piece = board[i]\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1\n        if (piece.type === BISHOP) {\n          bishops.push(sq_color)\n        }\n        num_pieces++\n      }\n    }\n\n    /* k vs. k */\n    if (num_pieces === 2) {\n      return true\n    } else if (\n      /* k vs. kn .... or .... k vs. kb */\n      num_pieces === 3 &&\n      (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)\n    ) {\n      return true\n    } else if (num_pieces === pieces[BISHOP] + 2) {\n      /* kb vs. kb where any number of bishops are all on the same color */\n      var sum = 0\n      var len = bishops.length\n      for (var i = 0; i < len; i++) {\n        sum += bishops[i]\n      }\n      if (sum === 0 || sum === len) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  function in_threefold_repetition() {\n    /* TODO: while this function is fine for casual use, a better\n     * implementation would use a Zobrist key (instead of FEN). the\n     * Zobrist key would be maintained in the make_move/undo_move functions,\n     * avoiding the costly that we do below.\n     */\n    var moves = []\n    var positions = {}\n    var repetition = false\n\n    while (true) {\n      var move = undo_move()\n      if (!move) break\n      moves.push(move)\n    }\n\n    while (true) {\n      /* remove the last two fields in the FEN string, they're not needed\n       * when checking for draw by rep */\n      var fen = generate_fen()\n        .split(' ')\n        .slice(0, 4)\n        .join(' ')\n\n      /* has the position occurred three or move times */\n      positions[fen] = fen in positions ? positions[fen] + 1 : 1\n      if (positions[fen] >= 3) {\n        repetition = true\n      }\n\n      if (!moves.length) {\n        break\n      }\n      make_move(moves.pop())\n    }\n\n    return repetition\n  }\n\n  function push(move) {\n    history.push({\n      move: move,\n      kings: { b: kings.b, w: kings.w },\n      turn: turn,\n      castling: { b: castling.b, w: castling.w },\n      ep_square: ep_square,\n      half_moves: half_moves,\n      move_number: move_number\n    })\n  }\n\n  function make_move(move) {\n    var us = turn\n    var them = swap_color(us)\n    push(move)\n\n    board[move.to] = board[move.from]\n    board[move.from] = null\n\n    /* if ep capture, remove the captured pawn */\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (turn === BLACK) {\n        board[move.to - 16] = null\n      } else {\n        board[move.to + 16] = null\n      }\n    }\n\n    /* if pawn promotion, replace with new piece */\n    if (move.flags & BITS.PROMOTION) {\n      board[move.to] = { type: move.promotion, color: us }\n    }\n\n    /* if we moved the king */\n    if (board[move.to].type === KING) {\n      kings[board[move.to].color] = move.to\n\n      /* if we castled, move the rook next to the king */\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        var castling_to = move.to - 1\n        var castling_from = move.to + 1\n        board[castling_to] = board[castling_from]\n        board[castling_from] = null\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        var castling_to = move.to + 1\n        var castling_from = move.to - 2\n        board[castling_to] = board[castling_from]\n        board[castling_from] = null\n      }\n\n      /* turn off castling */\n      castling[us] = ''\n    }\n\n    /* turn off castling if we move a rook */\n    if (castling[us]) {\n      for (var i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (\n          move.from === ROOKS[us][i].square &&\n          castling[us] & ROOKS[us][i].flag\n        ) {\n          castling[us] ^= ROOKS[us][i].flag\n          break\n        }\n      }\n    }\n\n    /* turn off castling if we capture a rook */\n    if (castling[them]) {\n      for (var i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (\n          move.to === ROOKS[them][i].square &&\n          castling[them] & ROOKS[them][i].flag\n        ) {\n          castling[them] ^= ROOKS[them][i].flag\n          break\n        }\n      }\n    }\n\n    /* if big pawn move, update the en passant square */\n    if (move.flags & BITS.BIG_PAWN) {\n      if (turn === 'b') {\n        ep_square = move.to - 16\n      } else {\n        ep_square = move.to + 16\n      }\n    } else {\n      ep_square = EMPTY\n    }\n\n    /* reset the 50 move counter if a pawn is moved or a piece is captured */\n    if (move.piece === PAWN) {\n      half_moves = 0\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      half_moves = 0\n    } else {\n      half_moves++\n    }\n\n    if (turn === BLACK) {\n      move_number++\n    }\n    turn = swap_color(turn)\n  }\n\n  function undo_move() {\n    var old = history.pop()\n    if (old == null) {\n      return null\n    }\n\n    var move = old.move\n    kings = old.kings\n    turn = old.turn\n    castling = old.castling\n    ep_square = old.ep_square\n    half_moves = old.half_moves\n    move_number = old.move_number\n\n    var us = turn\n    var them = swap_color(turn)\n\n    board[move.from] = board[move.to]\n    board[move.from].type = move.piece // to undo any promotions\n    board[move.to] = null\n\n    if (move.flags & BITS.CAPTURE) {\n      board[move.to] = { type: move.captured, color: them }\n    } else if (move.flags & BITS.EP_CAPTURE) {\n      var index\n      if (us === BLACK) {\n        index = move.to - 16\n      } else {\n        index = move.to + 16\n      }\n      board[index] = { type: PAWN, color: them }\n    }\n\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      var castling_to, castling_from\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castling_to = move.to + 1\n        castling_from = move.to - 1\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        castling_to = move.to - 2\n        castling_from = move.to + 1\n      }\n\n      board[castling_to] = board[castling_from]\n      board[castling_from] = null\n    }\n\n    return move\n  }\n\n  /* this function is used to uniquely identify ambiguous moves */\n  function get_disambiguator(move, sloppy) {\n    var moves = generate_moves({ legal: !sloppy })\n\n    var from = move.from\n    var to = move.to\n    var piece = move.piece\n\n    var ambiguities = 0\n    var same_rank = 0\n    var same_file = 0\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      var ambig_from = moves[i].from\n      var ambig_to = moves[i].to\n      var ambig_piece = moves[i].piece\n\n      /* if a move of the same piece type ends on the same to square, we'll\n       * need to add a disambiguator to the algebraic notation\n       */\n      if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {\n        ambiguities++\n\n        if (rank(from) === rank(ambig_from)) {\n          same_rank++\n        }\n\n        if (file(from) === file(ambig_from)) {\n          same_file++\n        }\n      }\n    }\n\n    if (ambiguities > 0) {\n      /* if there exists a similar moving piece on the same rank and file as\n       * the move in question, use the square as the disambiguator\n       */\n      if (same_rank > 0 && same_file > 0) {\n        return algebraic(from)\n      } else if (same_file > 0) {\n        /* if the moving piece rests on the same file, use the rank symbol as the\n         * disambiguator\n         */\n        return algebraic(from).charAt(1)\n      } else {\n        /* else use the file symbol */\n        return algebraic(from).charAt(0)\n      }\n    }\n\n    return ''\n  }\n\n  function ascii() {\n    var s = '   +------------------------+\\n'\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      /* display the rank */\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |'\n      }\n\n      /* empty piece */\n      if (board[i] == null) {\n        s += ' . '\n      } else {\n        var piece = board[i].type\n        var color = board[i].color\n        var symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n        s += ' ' + symbol + ' '\n      }\n\n      if ((i + 1) & 0x88) {\n        s += '|\\n'\n        i += 8\n      }\n    }\n    s += '   +------------------------+\\n'\n    s += '     a  b  c  d  e  f  g  h\\n'\n\n    return s\n  }\n\n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n  function move_from_san(move, sloppy) {\n    // strip off any move decorations: e.g Nf3+?!\n    var clean_move = stripped_san(move)\n\n    // if we're using the sloppy parser run a regex to grab piece, to, and from\n    // this should parse invalid SAN like: Pe2-e4, Rc1c4, Qf3xf7\n    if (sloppy) {\n      var matches = clean_move.match(\n        /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\n      )\n      if (matches) {\n        var piece = matches[1]\n        var from = matches[2]\n        var to = matches[3]\n        var promotion = matches[4]\n      }\n    }\n\n    var moves = generate_moves()\n    for (var i = 0, len = moves.length; i < len; i++) {\n      // try the strict parser first, then the sloppy parser if requested\n      // by the user\n      if (\n        clean_move === stripped_san(move_to_san(moves[i])) ||\n        (sloppy && clean_move === stripped_san(move_to_san(moves[i], true)))\n      ) {\n        return moves[i]\n      } else {\n        if (\n          matches &&\n          (!piece || piece.toLowerCase() == moves[i].piece) &&\n          SQUARES[from] == moves[i].from &&\n          SQUARES[to] == moves[i].to &&\n          (!promotion || promotion.toLowerCase() == moves[i].promotion)\n        ) {\n          return moves[i]\n        }\n      }\n    }\n\n    return null\n  }\n\n  /*****************************************************************************\n   * UTILITY FUNCTIONS\n   ****************************************************************************/\n  function rank(i) {\n    return i >> 4\n  }\n\n  function file(i) {\n    return i & 15\n  }\n\n  function algebraic(i) {\n    var f = file(i),\n      r = rank(i)\n    return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1)\n  }\n\n  function swap_color(c) {\n    return c === WHITE ? BLACK : WHITE\n  }\n\n  function is_digit(c) {\n    return '0123456789'.indexOf(c) !== -1\n  }\n\n  /* pretty = external move object */\n  function make_pretty(ugly_move) {\n    var move = clone(ugly_move)\n    move.san = move_to_san(move, false)\n    move.to = algebraic(move.to)\n    move.from = algebraic(move.from)\n\n    var flags = ''\n\n    for (var flag in BITS) {\n      if (BITS[flag] & move.flags) {\n        flags += FLAGS[flag]\n      }\n    }\n    move.flags = flags\n\n    return move\n  }\n\n  function clone(obj) {\n    var dupe = obj instanceof Array ? [] : {}\n\n    for (var property in obj) {\n      if (typeof property === 'object') {\n        dupe[property] = clone(obj[property])\n      } else {\n        dupe[property] = obj[property]\n      }\n    }\n\n    return dupe\n  }\n\n  function trim(str) {\n    return str.replace(/^\\s+|\\s+$/g, '')\n  }\n\n  /*****************************************************************************\n   * DEBUGGING UTILITIES\n   ****************************************************************************/\n  function perft(depth) {\n    var moves = generate_moves({ legal: false })\n    var nodes = 0\n    var color = turn\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i])\n      if (!king_attacked(color)) {\n        if (depth - 1 > 0) {\n          var child_nodes = perft(depth - 1)\n          nodes += child_nodes\n        } else {\n          nodes++\n        }\n      }\n      undo_move()\n    }\n\n    return nodes\n  }\n\n  return {\n    /***************************************************************************\n     * PUBLIC CONSTANTS (is there a better way to do this?)\n     **************************************************************************/\n    WHITE: WHITE,\n    BLACK: BLACK,\n    PAWN: PAWN,\n    KNIGHT: KNIGHT,\n    BISHOP: BISHOP,\n    ROOK: ROOK,\n    QUEEN: QUEEN,\n    KING: KING,\n    SQUARES: (function() {\n      /* from the ECMA-262 spec (section 12.6.4):\n       * \"The mechanics of enumerating the properties ... is\n       * implementation dependent\"\n       * so: for (var sq in SQUARES) { keys.push(sq); } might not be\n       * ordered correctly\n       */\n      var keys = []\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n        if (i & 0x88) {\n          i += 7\n          continue\n        }\n        keys.push(algebraic(i))\n      }\n      return keys\n    })(),\n    FLAGS: FLAGS,\n\n    /***************************************************************************\n     * PUBLIC API\n     **************************************************************************/\n    load: function(fen) {\n      return load(fen)\n    },\n\n    reset: function() {\n      return reset()\n    },\n\n    moves: function(options) {\n      /* The internal representation of a chess move is in 0x88 format, and\n       * not meant to be human-readable.  The code below converts the 0x88\n       * square coordinates to algebraic coordinates.  It also prunes an\n       * unnecessary move keys resulting from a verbose call.\n       */\n\n      var ugly_moves = generate_moves(options)\n      var moves = []\n\n      for (var i = 0, len = ugly_moves.length; i < len; i++) {\n        /* does the user want a full move object (most likely not), or just\n         * SAN\n         */\n        if (\n          typeof options !== 'undefined' &&\n          'verbose' in options &&\n          options.verbose\n        ) {\n          moves.push(make_pretty(ugly_moves[i]))\n        } else {\n          moves.push(move_to_san(ugly_moves[i], false))\n        }\n      }\n\n      return moves\n    },\n\n    in_check: function() {\n      return in_check()\n    },\n\n    in_checkmate: function() {\n      return in_checkmate()\n    },\n\n    in_stalemate: function() {\n      return in_stalemate()\n    },\n\n    in_draw: function() {\n      return (\n        half_moves >= 100 ||\n        in_stalemate() ||\n        insufficient_material() ||\n        in_threefold_repetition()\n      )\n    },\n\n    insufficient_material: function() {\n      return insufficient_material()\n    },\n\n    in_threefold_repetition: function() {\n      return in_threefold_repetition()\n    },\n\n    game_over: function() {\n      return (\n        half_moves >= 100 ||\n        in_checkmate() ||\n        in_stalemate() ||\n        insufficient_material() ||\n        in_threefold_repetition()\n      )\n    },\n\n    validate_fen: function(fen) {\n      return validate_fen(fen)\n    },\n\n    fen: function() {\n      return generate_fen()\n    },\n\n    board: function() {\n      var output = [],\n        row = []\n\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n        if (board[i] == null) {\n          row.push(null)\n        } else {\n          row.push({ type: board[i].type, color: board[i].color })\n        }\n        if ((i + 1) & 0x88) {\n          output.push(row)\n          row = []\n          i += 8\n        }\n      }\n\n      return output\n    },\n\n    pgn: function(options) {\n      /* using the specification from http://www.chessclub.com/help/PGN-spec\n       * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n       */\n      var newline =\n        typeof options === 'object' && typeof options.newline_char === 'string'\n          ? options.newline_char\n          : '\\n'\n      var max_width =\n        typeof options === 'object' && typeof options.max_width === 'number'\n          ? options.max_width\n          : 0\n      var result = []\n      var header_exists = false\n\n      /* add the PGN header headerrmation */\n      for (var i in header) {\n        /* TODO: order of enumerated properties in header object is not\n         * guaranteed, see ECMA-262 spec (section 12.6.4)\n         */\n        result.push('[' + i + ' \"' + header[i] + '\"]' + newline)\n        header_exists = true\n      }\n\n      if (header_exists && history.length) {\n        result.push(newline)\n      }\n\n      var append_comment = function(move_string) {\n        var comment = comments[generate_fen()]\n        if (typeof comment !== 'undefined') {\n          var delimiter = move_string.length > 0 ? ' ' : '';\n          move_string = `${move_string}${delimiter}{${comment}}`\n        }\n        return move_string\n      }\n\n      /* pop all of history onto reversed_history */\n      var reversed_history = []\n      while (history.length > 0) {\n        reversed_history.push(undo_move())\n      }\n\n      var moves = []\n      var move_string = ''\n\n      /* special case of a commented starting position with no moves */\n      if (reversed_history.length === 0) {\n        moves.push(append_comment(''))\n      }\n\n      /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\n      while (reversed_history.length > 0) {\n        move_string = append_comment(move_string)\n        var move = reversed_history.pop()\n\n        /* if the position started with black to move, start PGN with 1. ... */\n        if (!history.length && move.color === 'b') {\n          move_string = move_number + '. ...'\n        } else if (move.color === 'w') {\n          /* store the previous generated move_string if we have one */\n          if (move_string.length) {\n            moves.push(move_string)\n          }\n          move_string = move_number + '.'\n        }\n\n        move_string = move_string + ' ' + move_to_san(move, false)\n        make_move(move)\n      }\n\n      /* are there any other leftover moves? */\n      if (move_string.length) {\n        moves.push(append_comment(move_string))\n      }\n\n      /* is there a result? */\n      if (typeof header.Result !== 'undefined') {\n        moves.push(header.Result)\n      }\n\n      /* history should be back to what it was before we started generating PGN,\n       * so join together moves\n       */\n      if (max_width === 0) {\n        return result.join('') + moves.join(' ')\n      }\n\n      var strip = function() {\n        if (result.length > 0 && result[result.length - 1] === ' ') {\n          result.pop();\n          return true;\n        }\n        return false;\n      };\n\n      /* NB: this does not preserve comment whitespace. */\n      var wrap_comment = function(width, move) {\n        for (var token of move.split(' ')) {\n          if (!token) {\n            continue;\n          }\n          if (width + token.length > max_width) {\n            while (strip()) {\n              width--;\n            }\n            result.push(newline);\n            width = 0;\n          }\n          result.push(token);\n          width += token.length;\n          result.push(' ');\n          width++;\n        }\n        if (strip()) {\n          width--;\n        }\n        return width;\n      };\n\n      /* wrap the PGN output at max_width */\n      var current_width = 0\n      for (var i = 0; i < moves.length; i++) {\n        if (current_width + moves[i].length > max_width) {\n          if (moves[i].includes('{')) {\n            current_width = wrap_comment(current_width, moves[i]);\n            continue;\n          }\n        }\n        /* if the current move will push past max_width */\n        if (current_width + moves[i].length > max_width && i !== 0) {\n          /* don't end the line with whitespace */\n          if (result[result.length - 1] === ' ') {\n            result.pop()\n          }\n\n          result.push(newline)\n          current_width = 0\n        } else if (i !== 0) {\n          result.push(' ')\n          current_width++\n        }\n        result.push(moves[i])\n        current_width += moves[i].length\n      }\n\n      return result.join('')\n    },\n\n    load_pgn: function(pgn, options) {\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy =\n        typeof options !== 'undefined' && 'sloppy' in options\n          ? options.sloppy\n          : false\n\n      function mask(str) {\n        return str.replace(/\\\\/g, '\\\\')\n      }\n\n      function has_keys(object) {\n        for (var key in object) {\n          return true\n        }\n        return false\n      }\n\n      function parse_pgn_header(header, options) {\n        var newline_char =\n          typeof options === 'object' &&\n          typeof options.newline_char === 'string'\n            ? options.newline_char\n            : '\\r?\\n'\n        var header_obj = {}\n        var headers = header.split(new RegExp(mask(newline_char)))\n        var key = ''\n        var value = ''\n\n        for (var i = 0; i < headers.length; i++) {\n          key = headers[i].replace(/^\\[([A-Z][A-Za-z]*)\\s.*\\]$/, '$1')\n          value = headers[i].replace(/^\\[[A-Za-z]+\\s\"(.*)\"\\ *\\]$/, '$1')\n          if (trim(key).length > 0) {\n            header_obj[key] = value\n          }\n        }\n\n        return header_obj\n      }\n\n      var newline_char =\n        typeof options === 'object' && typeof options.newline_char === 'string'\n          ? options.newline_char\n          : '\\r?\\n'\n\n      // RegExp to split header. Takes advantage of the fact that header and movetext\n      // will always have a blank line between them (ie, two newline_char's).\n      // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\r?\\n){2}/\n      var header_regex = new RegExp(\n        '^(\\\\[((?:' +\n          mask(newline_char) +\n          ')|.)*\\\\])' +\n          '(?:' +\n          mask(newline_char) +\n          '){2}'\n      )\n\n      // If no header given, begin with moves.\n      var header_string = header_regex.test(pgn)\n        ? header_regex.exec(pgn)[1]\n        : ''\n\n      // Put the board in the starting position\n      reset()\n\n      /* parse PGN header */\n      var headers = parse_pgn_header(header_string, options)\n      for (var key in headers) {\n        set_header([key, headers[key]])\n      }\n\n      /* load the starting position indicated by [Setup '1'] and\n       * [FEN position] */\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers && load(headers['FEN'], true))) {\n          // second argument to load: don't clear the headers\n          return false\n        }\n      }\n\n      /* NB: the regexes below that delete move numbers, recursive\n       * annotations, and numeric annotation glyphs may also match\n       * text in comments. To prevent this, we transform comments\n       * by hex-encoding them in place and decoding them again after\n       * the other tokens have been deleted.\n       *\n       * While the spec states that PGN files should be ASCII encoded,\n       * we use {en,de}codeURIComponent here to support arbitrary UTF8\n       * as a convenience for modern users */\n\n      var to_hex = function(string) {\n        return Array\n          .from(string)\n          .map(function(c) {\n            /* encodeURI doesn't transform most ASCII characters,\n             * so we handle these ourselves */\n            return c.charCodeAt(0) < 128\n              ? c.charCodeAt(0).toString(16)\n              : encodeURIComponent(c).replace(/\\%/g, '').toLowerCase()\n          })\n          .join('')\n      }\n\n      var from_hex = function(string) {\n        return string.length == 0\n          ? ''\n          : decodeURIComponent('%' + string.match(/.{1,2}/g).join('%'))\n      }\n\n      var encode_comment = function(string) {\n        string = string.replace(new RegExp(mask(newline_char), 'g'), ' ')\n        return `{${to_hex(string.slice(1, string.length - 1))}}`\n      }\n\n      var decode_comment = function(string) {\n        if (string.startsWith('{') && string.endsWith('}')) {\n          return from_hex(string.slice(1, string.length - 1))\n        }\n      }\n\n      /* delete header to get the moves */\n      var ms = pgn\n        .replace(header_string, '')\n        .replace(\n          /* encode comments so they don't get deleted below */\n          new RegExp(`(\\{[^}]*\\})+?|;([^${mask(newline_char)}]*)`, 'g'),\n          function(match, bracket, semicolon) {\n            return bracket !== undefined\n              ? encode_comment(bracket)\n              : ' ' + encode_comment(`{${semicolon.slice(1)}}`)\n          }\n        )\n        .replace(new RegExp(mask(newline_char), 'g'), ' ')\n\n      /* delete recursive annotation variations */\n      var rav_regex = /(\\([^\\(\\)]+\\))+?/g\n      while (rav_regex.test(ms)) {\n        ms = ms.replace(rav_regex, '')\n      }\n\n      /* delete move numbers */\n      ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '')\n\n      /* delete ... indicating black to move */\n      ms = ms.replace(/\\.\\.\\./g, '')\n\n      /* delete numeric annotation glyphs */\n      ms = ms.replace(/\\$\\d+/g, '')\n\n      /* trim and get array of moves */\n      var moves = trim(ms).split(new RegExp(/\\s+/))\n\n      /* delete empty entries */\n      moves = moves\n        .join(',')\n        .replace(/,,+/g, ',')\n        .split(',')\n      var move = ''\n\n      for (var half_move = 0; half_move < moves.length - 1; half_move++) {\n        var comment = decode_comment(moves[half_move])\n        if (comment !== undefined) {\n          comments[generate_fen()] = comment\n          continue\n        }\n        move = move_from_san(moves[half_move], sloppy)\n\n        /* move not possible! (don't clear the board to examine to show the\n         * latest valid position)\n         */\n        if (move == null) {\n          return false\n        } else {\n          make_move(move)\n        }\n      }\n\n      comment = decode_comment(moves[moves.length - 1])\n      if (comment !== undefined) {\n        comments[generate_fen()] = comment\n        moves.pop()\n      }\n\n      /* examine last move */\n      move = moves[moves.length - 1]\n      if (POSSIBLE_RESULTS.indexOf(move) > -1) {\n        if (has_keys(header) && typeof header.Result === 'undefined') {\n          set_header(['Result', move])\n        }\n      } else {\n        move = move_from_san(move, sloppy)\n        if (move == null) {\n          return false\n        } else {\n          make_move(move)\n        }\n      }\n      return true\n    },\n\n    header: function() {\n      return set_header(arguments)\n    },\n\n    ascii: function() {\n      return ascii()\n    },\n\n    turn: function() {\n      return turn\n    },\n\n    move: function(move, options) {\n      /* The move function can be called with in the following parameters:\n       *\n       * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\n       *\n       * .move({ from: 'h7', <- where the 'move' is a move object (additional\n       *         to :'h8',      fields are ignored)\n       *         promotion: 'q',\n       *      })\n       */\n\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy =\n        typeof options !== 'undefined' && 'sloppy' in options\n          ? options.sloppy\n          : false\n\n      var move_obj = null\n\n      if (typeof move === 'string') {\n        move_obj = move_from_san(move, sloppy)\n      } else if (typeof move === 'object') {\n        var moves = generate_moves()\n\n        /* convert the pretty move object to an ugly move object */\n        for (var i = 0, len = moves.length; i < len; i++) {\n          if (\n            move.from === algebraic(moves[i].from) &&\n            move.to === algebraic(moves[i].to) &&\n            (!('promotion' in moves[i]) ||\n              move.promotion === moves[i].promotion)\n          ) {\n            move_obj = moves[i]\n            break\n          }\n        }\n      }\n\n      /* failed to find move */\n      if (!move_obj) {\n        return null\n      }\n\n      /* need to make a copy of move because we can't generate SAN after the\n       * move is made\n       */\n      var pretty_move = make_pretty(move_obj)\n\n      make_move(move_obj)\n\n      return pretty_move\n    },\n\n    undo: function() {\n      var move = undo_move()\n      return move ? make_pretty(move) : null\n    },\n\n    clear: function() {\n      return clear()\n    },\n\n    put: function(piece, square) {\n      return put(piece, square)\n    },\n\n    get: function(square) {\n      return get(square)\n    },\n\n    remove: function(square) {\n      return remove(square)\n    },\n\n    perft: function(depth) {\n      return perft(depth)\n    },\n\n    square_color: function(square) {\n      if (square in SQUARES) {\n        var sq_0x88 = SQUARES[square]\n        return (rank(sq_0x88) + file(sq_0x88)) % 2 === 0 ? 'light' : 'dark'\n      }\n\n      return null\n    },\n\n    history: function(options) {\n      var reversed_history = []\n      var move_history = []\n      var verbose =\n        typeof options !== 'undefined' &&\n        'verbose' in options &&\n        options.verbose\n\n      while (history.length > 0) {\n        reversed_history.push(undo_move())\n      }\n\n      while (reversed_history.length > 0) {\n        var move = reversed_history.pop()\n        if (verbose) {\n          move_history.push(make_pretty(move))\n        } else {\n          move_history.push(move_to_san(move))\n        }\n        make_move(move)\n      }\n\n      return move_history\n    },\n\n    get_comment: function() {\n      return comments[generate_fen()];\n    },\n\n    set_comment: function(comment) {\n      comments[generate_fen()] = comment.replace('{', '[').replace('}', ']');\n    },\n\n    delete_comment: function() {\n      var comment = comments[generate_fen()];\n      delete comments[generate_fen()];\n      return comment;\n    },\n\n    get_comments: function() {\n      prune_comments();\n      return Object.keys(comments).map(function(fen) {\n        return {fen: fen, comment: comments[fen]};\n      });\n    },\n\n    delete_comments: function() {\n      prune_comments();\n      return Object.keys(comments)\n        .map(function(fen) {\n          var comment = comments[fen];\n          delete comments[fen];\n          return {fen: fen, comment: comment};\n        });\n    }\n  }\n}\n\n/* export Chess object if using node or any other CommonJS compatible\n * environment */\nif (typeof exports !== 'undefined') exports.Chess = Chess\n/* export Chess object for any RequireJS compatible environment */\nif (typeof define !== 'undefined')\n  define(function() {\n    return Chess\n  })\n"],"mappings":"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ACjD,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAG,CAAC,EAAE,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAChD,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EACjD,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,CAC/C;;EAED;EACA,IAAIC,IAAI,GAAG,CACR,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAE,CAAC,EAC5D,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAG,CAAC,CAAC,EAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAC,CAAC,EAAE,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAE,CAAC,EAC5D,CAAC,EAAC,CAAC,EAAE,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAG,CAAC,EAAC,CAAC,EA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"},"metadata":{},"sourceType":"script"}