{"ast":null,"code":"import { __assign, __spreadArrays } from 'tslib';\nimport { Observable } from 'rxjs';\nimport { map, filter, scan, distinctUntilChanged } from 'rxjs/operators';\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction _fromRef(ref, options) {\n  /* eslint-enable @typescript-eslint/no-explicit-any */\n  return new Observable(function (subscriber) {\n    var unsubscribe = ref.onSnapshot(options || {}, subscriber);\n    return {\n      unsubscribe: unsubscribe\n    };\n  });\n}\nfunction fromRef(ref, options) {\n  return _fromRef(ref, options);\n}\nfunction fromDocRef(ref, options) {\n  return fromRef(ref, options);\n}\nfunction fromCollectionRef(ref, options) {\n  return fromRef(ref, options);\n}\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nfunction doc(ref) {\n  return fromDocRef(ref);\n}\n/**\r\n * Returns a stream of a document, mapped to its data payload and optionally the document ID\r\n * @param query\r\n */\nfunction docData(ref, idField) {\n  return doc(ref).pipe(map(function (snap) {\n    return snapToData(snap, idField);\n  }));\n}\nfunction snapToData(snapshot, idField) {\n  var _a;\n  return __assign(__assign({}, snapshot.data()), idField ? (_a = {}, _a[idField] = snapshot.id, _a) : null);\n}\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\nvar ALL_EVENTS = ['added', 'modified', 'removed'];\n/**\r\n * Create an operator that determines if a the stream of document changes\r\n * are specified by the event filter. If the document change type is not\r\n * in specified events array, it will not be emitted.\r\n */\nvar filterEvents = function (events) {\n  return filter(function (changes) {\n    var hasChange = false;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      if (events && events.indexOf(change.type) >= 0) {\n        hasChange = true;\n        break;\n      }\n    }\n    return hasChange;\n  });\n};\n/**\r\n * Create an operator that filters out empty changes. We provide the\r\n * ability to filter on events, which means all changes can be filtered out.\r\n * This creates an empty array and would be incorrect to emit.\r\n */\nvar filterEmpty = filter(function (changes) {\n  return changes.length > 0;\n});\n/**\r\n * Splice arguments on top of a sliced array, to break top-level ===\r\n * this is useful for change-detection\r\n */\nfunction sliceAndSplice(original, start, deleteCount) {\n  var args = [];\n  for (var _i = 3; _i < arguments.length; _i++) {\n    args[_i - 3] = arguments[_i];\n  }\n  var returnArray = original.slice();\n  returnArray.splice.apply(returnArray, __spreadArrays([start, deleteCount], args));\n  return returnArray;\n}\n/**\r\n * Creates a new sorted array from a new change.\r\n * @param combined\r\n * @param change\r\n */\nfunction processIndividualChange(combined, change) {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) ;else {\n        return sliceAndSplice(combined, change.newIndex, 0, change);\n      }\n      break;\n    case 'modified':\n      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          var copiedArray = combined.slice();\n          copiedArray.splice(change.oldIndex, 1);\n          copiedArray.splice(change.newIndex, 0, change);\n          return copiedArray;\n        } else {\n          return sliceAndSplice(combined, change.newIndex, 1, change);\n        }\n      }\n      break;\n    case 'removed':\n      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        return sliceAndSplice(combined, change.oldIndex, 1);\n      }\n      break;\n  }\n  return combined;\n}\n/**\r\n * Combines the total result set from the current set of changes from an incoming set\r\n * of changes.\r\n * @param current\r\n * @param changes\r\n * @param events\r\n */\nfunction processDocumentChanges(current, changes, events) {\n  if (events === void 0) {\n    events = ALL_EVENTS;\n  }\n  changes.forEach(function (change) {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = processIndividualChange(current, change);\n    }\n  });\n  return current;\n}\n/**\r\n * Return a stream of document changes on a query. These results are not in sort order but in\r\n * order of occurence.\r\n * @param query\r\n */\nfunction collectionChanges(query, events) {\n  if (events === void 0) {\n    events = ALL_EVENTS;\n  }\n  return fromCollectionRef(query).pipe(map(function (snapshot) {\n    return snapshot.docChanges();\n  }), filterEvents(events), filterEmpty);\n}\n/**\r\n * Return a stream of document snapshots on a query. These results are in sort order.\r\n * @param query\r\n */\nfunction collection(query) {\n  return fromCollectionRef(query).pipe(map(function (changes) {\n    return changes.docs;\n  }));\n}\n/**\r\n * Return a stream of document changes on a query. These results are in sort order.\r\n * @param query\r\n */\nfunction sortedChanges(query, events) {\n  return collectionChanges(query, events).pipe(scan(function (current, changes) {\n    return processDocumentChanges(current, changes, events);\n  }, []), distinctUntilChanged());\n}\n/**\r\n * Create a stream of changes as they occur it time. This method is similar\r\n * to docChanges() but it collects each event in an array over time.\r\n */\nfunction auditTrail(query, events) {\n  return collectionChanges(query, events).pipe(scan(function (current, action) {\n    return __spreadArrays(current, action);\n  }, []));\n}\n/**\r\n * Returns a stream of documents mapped to their data payload, and optionally the document ID\r\n * @param query\r\n */\nfunction collectionData(query, idField) {\n  return collection(query).pipe(map(function (arr) {\n    return arr.map(function (snap) {\n      return snapToData(snap, idField);\n    });\n  }));\n}\nexport { auditTrail, collection, collectionChanges, collectionData, doc, docData, fromCollectionRef, fromDocRef, fromRef, snapToData, sortedChanges };","map":{"version":3,"mappings":"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","names":["_fromRef","ref","options","Observable","unsubscribe","onSnapshot","subscriber","fromRef","fromDocRef","fromCollectionRef","doc","docData","idField","pipe","map","snap","snapToData","snapshot","data","_a","id","ALL_EVENTS","filterEvents","events","changes","hasChange","i","length","change","indexOf","type","filterEmpty","filter","sliceAndSplice","original","start","deleteCount","_i","args","returnArray","slice","splice","processIndividualChange","combined","newIndex","isEqual","oldIndex","copiedArray","processDocumentChanges","current","forEach","collectionChanges","query","docChanges","collection","docs","sortedChanges","scan","distinctUntilChanged","auditTrail","action","collectionData","arr"],"sources":["../fromRef.ts","../document/index.ts","../collection/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport firebase from 'firebase/app';\nimport { Observable } from 'rxjs';\n\ntype DocumentReference = firebase.firestore.DocumentReference;\ntype SnapshotListenOptions = firebase.firestore.SnapshotListenOptions;\ntype Query = firebase.firestore.Query;\ntype DocumentSnapshot = firebase.firestore.DocumentSnapshot;\ntype QuerySnapshot = firebase.firestore.QuerySnapshot;\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction _fromRef(\n  ref: any,\n  options: SnapshotListenOptions | undefined\n): Observable<any> {\n  /* eslint-enable @typescript-eslint/no-explicit-any */\n  return new Observable(subscriber => {\n    const unsubscribe = ref.onSnapshot(options || {}, subscriber);\n    return { unsubscribe };\n  });\n}\n\nexport function fromRef(\n  ref: DocumentReference | Query,\n  options?: SnapshotListenOptions\n): Observable<{}> {\n  return _fromRef(ref, options);\n}\n\nexport function fromDocRef(\n  ref: DocumentReference,\n  options?: SnapshotListenOptions\n): Observable<DocumentSnapshot> {\n  return fromRef(ref, options) as Observable<DocumentSnapshot>;\n}\n\nexport function fromCollectionRef(\n  ref: Query,\n  options?: SnapshotListenOptions\n): Observable<QuerySnapshot> {\n  return fromRef(ref, options) as Observable<QuerySnapshot>;\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport firebase from 'firebase/app';\nimport { fromDocRef } from '../fromRef';\nimport { map } from 'rxjs/operators';\nimport { Observable } from 'rxjs';\n\ntype DocumentReference = firebase.firestore.DocumentReference;\ntype DocumentSnapshot = firebase.firestore.DocumentSnapshot;\n\nexport function doc(ref: DocumentReference): Observable<DocumentSnapshot> {\n  return fromDocRef(ref);\n}\n\n/**\n * Returns a stream of a document, mapped to its data payload and optionally the document ID\n * @param query\n */\nexport function docData<T>(\n  ref: DocumentReference,\n  idField?: string\n): Observable<T> {\n  return doc(ref).pipe(map(snap => snapToData(snap, idField) as T));\n}\n\nexport function snapToData(snapshot: DocumentSnapshot, idField?: string): {} {\n  return {\n    ...snapshot.data(),\n    ...(idField ? { [idField]: snapshot.id } : null)\n  };\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport firebase from 'firebase/app';\nimport { fromCollectionRef } from '../fromRef';\nimport { Observable, MonoTypeOperatorFunction } from 'rxjs';\nimport { map, filter, scan, distinctUntilChanged } from 'rxjs/operators';\nimport { snapToData } from '../document';\n\ntype DocumentChangeType = firebase.firestore.DocumentChangeType;\ntype DocumentChange = firebase.firestore.DocumentChange;\ntype Query = firebase.firestore.Query;\ntype QueryDocumentSnapshot = firebase.firestore.QueryDocumentSnapshot;\n\nconst ALL_EVENTS: DocumentChangeType[] = ['added', 'modified', 'removed'];\n\n/**\n * Create an operator that determines if a the stream of document changes\n * are specified by the event filter. If the document change type is not\n * in specified events array, it will not be emitted.\n */\nconst filterEvents = (\n  events?: DocumentChangeType[]\n): MonoTypeOperatorFunction<DocumentChange[]> =>\n  filter((changes: DocumentChange[]) => {\n    let hasChange = false;\n    for (let i = 0; i < changes.length; i++) {\n      const change = changes[i];\n      if (events && events.indexOf(change.type) >= 0) {\n        hasChange = true;\n        break;\n      }\n    }\n    return hasChange;\n  });\n\n/**\n * Create an operator that filters out empty changes. We provide the\n * ability to filter on events, which means all changes can be filtered out.\n * This creates an empty array and would be incorrect to emit.\n */\nconst filterEmpty = filter((changes: DocumentChange[]) => changes.length > 0);\n\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\nfunction sliceAndSplice<T>(\n  original: T[],\n  start: number,\n  deleteCount: number,\n  ...args: T[]\n): T[] {\n  const returnArray = original.slice();\n  returnArray.splice(start, deleteCount, ...args);\n  return returnArray;\n}\n\n/**\n * Creates a new sorted array from a new change.\n * @param combined\n * @param change\n */\nfunction processIndividualChange(\n  combined: DocumentChange[],\n  change: DocumentChange\n): DocumentChange[] {\n  switch (change.type) {\n    case 'added':\n      if (\n        combined[change.newIndex] &&\n        combined[change.newIndex].doc.ref.isEqual(change.doc.ref)\n      ) {\n        // Skip duplicate emissions. This is rare.\n        // TODO: Investigate possible bug in SDK.\n      } else {\n        return sliceAndSplice(combined, change.newIndex, 0, change);\n      }\n      break;\n    case 'modified':\n      if (\n        combined[change.oldIndex] == null ||\n        combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)\n      ) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          const copiedArray = combined.slice();\n          copiedArray.splice(change.oldIndex, 1);\n          copiedArray.splice(change.newIndex, 0, change);\n          return copiedArray;\n        } else {\n          return sliceAndSplice(combined, change.newIndex, 1, change);\n        }\n      }\n      break;\n    case 'removed':\n      if (\n        combined[change.oldIndex] &&\n        combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)\n      ) {\n        return sliceAndSplice(combined, change.oldIndex, 1);\n      }\n      break;\n    default: // ignore\n  }\n  return combined;\n}\n\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @param current\n * @param changes\n * @param events\n */\nfunction processDocumentChanges(\n  current: DocumentChange[],\n  changes: DocumentChange[],\n  events: DocumentChangeType[] = ALL_EVENTS\n): DocumentChange[] {\n  changes.forEach(change => {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = processIndividualChange(current, change);\n    }\n  });\n  return current;\n}\n\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @param query\n */\nexport function collectionChanges(\n  query: Query,\n  events: DocumentChangeType[] = ALL_EVENTS\n): Observable<DocumentChange[]> {\n  return fromCollectionRef(query).pipe(\n    map(snapshot => snapshot.docChanges()),\n    filterEvents(events),\n    filterEmpty\n  );\n}\n\n/**\n * Return a stream of document snapshots on a query. These results are in sort order.\n * @param query\n */\nexport function collection(query: Query): Observable<QueryDocumentSnapshot[]> {\n  return fromCollectionRef(query).pipe(map(changes => changes.docs));\n}\n\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @param query\n */\nexport function sortedChanges(\n  query: Query,\n  events?: DocumentChangeType[]\n): Observable<DocumentChange[]> {\n  return collectionChanges(query, events).pipe(\n    scan(\n      (current: DocumentChange[], changes: DocumentChange[]) =>\n        processDocumentChanges(current, changes, events),\n      []\n    ),\n    distinctUntilChanged()\n  );\n}\n\n/**\n * Create a stream of changes as they occur it time. This method is similar\n * to docChanges() but it collects each event in an array over time.\n */\nexport function auditTrail(\n  query: Query,\n  events?: DocumentChangeType[]\n): Observable<DocumentChange[]> {\n  return collectionChanges(query, events).pipe(\n    scan((current, action) => [...current, ...action], [] as DocumentChange[])\n  );\n}\n\n/**\n * Returns a stream of documents mapped to their data payload, and optionally the document ID\n * @param query\n */\nexport function collectionData<T>(\n  query: Query,\n  idField?: string\n): Observable<T[]> {\n  return collection(query).pipe(\n    map(arr => {\n      return arr.map(snap => snapToData(snap, idField) as T);\n    })\n  );\n}\n"]},"metadata":{},"sourceType":"module"}